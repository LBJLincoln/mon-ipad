{
  "workflow_file": "TEST - SOTA 2026 - WF2 Graph RAG V3.3 - CORRECTED (1).json",
  "workflow_name": "TEST - SOTA 2026 - WF2 Graph RAG V3.3 - CORRECTED",
  "generated_at": "2026-02-05T12:00:00.000Z",
  "generated_by": "patch-writer-agent",
  "patch_format": "RFC 6902 (JSON Patch)",
  "total_patches": 12,
  "patches": [
    {
      "op": "replace",
      "path": "/nodes/11/disabled",
      "value": false,
      "metadata": {
        "reason": "Re-enable Shield #9 Export Trace node - observability telemetry must be active for production monitoring and debugging via OTEL collector",
        "issue_ref": "ISSUE-GR-01",
        "severity": "P0",
        "before": true,
        "node_name": "Shield #9: Export Trace",
        "node_index": 11
      }
    },
    {
      "op": "replace",
      "path": "/nodes/7/parameters/jsonBody",
      "value": "={\n  \"model\": \"{{ $vars.RERANKER_MODEL || 'rerank-v3.5' }}\",\n  \"query\": \"{{ $node['OTEL Init'].json.query }}\",\n  \"documents\": {{ JSON.stringify(($json.merged_results || []).map(d => d.content || '').filter(c => c.length > 0).slice(0, 25)) }},\n  \"top_n\": 10\n}",
      "metadata": {
        "reason": "Upgrade Cohere reranker model from rerank-multilingual-v3.0 to rerank-v3.5 for +31% reasoning improvement (Azure AI 2025 benchmark, ref R01)",
        "issue_ref": "ISSUE-GR-02",
        "severity": "P0",
        "before": "rerank-multilingual-v3.0",
        "after": "rerank-v3.5",
        "node_name": "WF3: Cohere Reranker",
        "node_index": 7
      }
    },
    {
      "op": "replace",
      "path": "/nodes/19/parameters/jsCode",
      "value": "const embeddingData = $json;\n\n// Check if we have a valid embedding\nlet embedding = [];\n\n// Try different response formats\nif (embeddingData.data?.[0]?.embedding) {\n  embedding = embeddingData.data[0].embedding;\n} else if (embeddingData.body?.data?.[0]?.embedding) {\n  embedding = embeddingData.body.data[0].embedding;\n} else if (Array.isArray(embeddingData.embedding)) {\n  embedding = embeddingData.embedding;\n}\n\n// PATCHED: Configurable embedding dimension via workflow variable\n// Supports: text-embedding-3-small (1536), text-embedding-3-large (3072), ada-002 (1536)\nconst VALID_DIMENSIONS = [256, 384, 512, 768, 1024, 1536, 3072];\nconst configuredDim = parseInt($vars.EMBEDDING_DIMENSION) || 1536;\nconst expectedDim = VALID_DIMENSIONS.includes(configuredDim) ? configuredDim : 1536;\n\nif (embedding.length !== expectedDim) {\n  throw new Error(`Invalid embedding dimension: got ${embedding.length}, expected ${expectedDim}. Set $vars.EMBEDDING_DIMENSION to override.`);\n}\n\nreturn [{\n  json: {\n    embedding: embedding,\n    dimension: embedding.length,\n    configured_dimension: expectedDim\n  }\n}];",
      "metadata": {
        "reason": "Replace hardcoded 1536 embedding dimension with configurable $vars.EMBEDDING_DIMENSION, validated against a whitelist of known dimensions. Allows switching embedding models without code changes.",
        "issue_ref": "ISSUE-GR-05",
        "severity": "P1",
        "before": "const expectedDim = 1536; (hardcoded)",
        "after": "const expectedDim = parseInt($vars.EMBEDDING_DIMENSION) || 1536; (configurable via workflow variable, validated against whitelist)",
        "node_name": "Validate Embedding",
        "node_index": 19,
        "required_variable": "EMBEDDING_DIMENSION (optional, defaults to 1536)"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/2/parameters/jsCode",
      "value": "// CORRECTED Neo4j Query Builder - Neo4j 5.x syntax compatible\n// Fixed: EXISTS() -> IS NOT NULL\n// PATCHED ISSUE-GR-08: Unicode-safe entity sanitization\n\nconst initData = $node['OTEL Init'].json;\nlet hydeResponse = {};\ntry {\n  hydeResponse = JSON.parse($json.choices?.[0]?.message?.content || '{}');\n} catch (e) {\n  hydeResponse = { entities: [], hyde_document: '' };\n}\n\nconst hydeEntities = hydeResponse.entities || [];\n\n// PATCHED: Unicode-safe sanitization (supports accents, diacritics, CJK, Cyrillic, etc.)\nconst validEntities = hydeEntities\n  .filter(e => e && typeof e.name === 'string')\n  .map(e => e.name.replace(/[^\\p{L}\\p{N}\\-_\\s]/gu, '').substring(0, 100))\n  .slice(0, 20);\n\nif (validEntities.length === 0) {\n  return [{ \n    json: {\n      skip_neo4j: true, \n      reason: 'No valid entities extracted', \n      hyde_document: hydeResponse.hyde_document \n    }\n  }];\n}\n\n// === CONFIGURATION TRAVERSAL ===\nconst MAX_DEPTH = 3;\nconst MAX_RESULTS = 100;\n\n// === CORRECTED RELATIONSHIP WEIGHTS (matching YOUR Neo4j) ===\nconst RELATIONSHIP_WEIGHTS = {\n  'A_CREE': 1.5,           // Created\n  'CONNECTE': 1.3,         // Connected to\n  'ETUDIE': 1.2,           // Studies\n  'UTILISE': 1.2,          // Uses\n  'EXPOSE_A': 1.1,         // Exposes to\n  'CAUSE_PAR': 1.4,        // Caused by\n  'PROTEGE_CONTRE': 1.3,   // Protects against\n  'VISE_A_LIMITER': 1.1,   // Aims to limit\n  'SOUS_ENSEMBLE_DE': 1.0, // Subset of\n  'CIBLE': 1.2,            // Targets\n  'ETEND': 1.0             // Extends\n};\n\n// === NEO4J 5.x COMPATIBLE QUERY - FIXED EXISTS() ===\nconst correctedQuery = `\nMATCH (n)\nWHERE n.name IN $entity_names\n  AND (n.tenant_id = $tenant_id OR n.tenant_id IS NULL)\nWITH n, \n     CASE \n       WHEN n:Organization THEN 1.3\n       WHEN n:Person THEN 1.2\n       WHEN n:City THEN 1.1\n       WHEN n:Museum THEN 1.2\n       WHEN n:Technology THEN 1.0\n       WHEN n:Disease THEN 1.0\n       ELSE 0.9 \n     END as entity_priority\nORDER BY entity_priority DESC\nLIMIT 10\n\nOPTIONAL MATCH path = (n)-[r*1..${MAX_DEPTH}]-(m)\nWHERE (m.tenant_id = $tenant_id OR m.tenant_id IS NULL)\nWITH path, n as startNode, entity_priority,\n     reduce(score = entity_priority, rel IN relationships(path) | \n       score + CASE type(rel)\n         WHEN 'A_CREE' THEN 1.5\n         WHEN 'CAUSE_PAR' THEN 1.4\n         WHEN 'CONNECTE' THEN 1.3\n         WHEN 'PROTEGE_CONTRE' THEN 1.3\n         WHEN 'ETUDIE' THEN 1.2\n         WHEN 'UTILISE' THEN 1.2\n         WHEN 'CIBLE' THEN 1.2\n         WHEN 'EXPOSE_A' THEN 1.1\n         WHEN 'VISE_A_LIMITER' THEN 1.1\n         WHEN 'SOUS_ENSEMBLE_DE' THEN 1.0\n         WHEN 'ETEND' THEN 1.0\n         ELSE 0.8\n       END\n     ) as path_score,\n     length(path) as path_length\n\nWHERE path_score > (path_length * 0.6)\n\nRETURN \n  startNode.name as start_entity,\n  [node IN nodes(path) | {name: node.name, type: labels(node)[0]}] as path_nodes,\n  [rel IN relationships(path) | type(rel)] as path_relations,\n  path_score,\n  path_length\nORDER BY path_score DESC\nLIMIT $max_results\n`;\n\nreturn [{\n  json: {\n    skip_neo4j: false,\n    query: correctedQuery,\n    parameters: {\n      entity_names: validEntities,\n      tenant_id: initData.user_context.tenant_id,\n      max_results: MAX_RESULTS\n    },\n    hyde_document: hydeResponse.hyde_document,\n    entities: validEntities,\n    traversal_config: {\n      max_depth: MAX_DEPTH,\n      relationship_weights: RELATIONSHIP_WEIGHTS\n    },\n    _debug: {\n      entities_found: validEntities.length,\n      schema_corrected: true,\n      french_relationships: true,\n      neo4j_5x_compatible: true\n    }\n  }\n}];",
      "metadata": {
        "reason": "Fix entity name sanitization regex to support Unicode characters beyond Latin-1 range (accented chars, diacritics, CJK, Cyrillic, etc.). Original regex /[^a-zA-Z\\u00C0-\\u00FF0-9\\-_\\s]/g rejected valid accented characters outside U+00C0-U+00FF. Replaced with Unicode property escapes /[^\\p{L}\\p{N}\\-_\\s]/gu.",
        "issue_ref": "ISSUE-GR-08",
        "severity": "P2",
        "before": "/[^a-zA-ZA-y0-9\\\\-_\\\\s]/g",
        "after": "/[^\\\\p{L}\\\\p{N}\\\\-_\\\\s]/gu",
        "node_name": "Neo4j Query Builder (Deep Traversal V2)",
        "node_index": 2,
        "note": "This patch is standalone. If G01 is also applied, G01 supersedes this patch as it replaces the entire jsCode with the unicode fix included."
      }
    },
    {
      "op": "add",
      "path": "/nodes/7/retryOnFail",
      "value": true,
      "metadata": {
        "reason": "Add retry-on-fail to Cohere Reranker node to handle transient API failures and rate limits gracefully",
        "issue_ref": "ISSUE-GR-09",
        "severity": "P2",
        "node_name": "WF3: Cohere Reranker",
        "node_index": 7
      }
    },
    {
      "op": "add",
      "path": "/nodes/7/maxTries",
      "value": 3,
      "metadata": {
        "reason": "Set maximum retry attempts to 3 for Cohere Reranker",
        "issue_ref": "ISSUE-GR-09",
        "severity": "P2",
        "node_name": "WF3: Cohere Reranker",
        "node_index": 7
      }
    },
    {
      "op": "add",
      "path": "/nodes/7/waitBetweenTries",
      "value": 2000,
      "metadata": {
        "reason": "Set 2-second wait between retry attempts for Cohere Reranker to respect rate limits",
        "issue_ref": "ISSUE-GR-09",
        "severity": "P2",
        "node_name": "WF3: Cohere Reranker",
        "node_index": 7
      }
    },
    {
      "op": "replace",
      "path": "/nodes/2/parameters/jsCode",
      "value": "// Neo4j Query Builder - Deep Traversal V2 + Path Pruning (SOTA 2026 G01)\n// Neo4j 5.x compatible - EXISTS() replaced with IS NOT NULL\n// G01: Cycle elimination + path deduplication\n// GR-08: Unicode-safe entity sanitization\n\nconst initData = $node['OTEL Init'].json;\nlet hydeResponse = {};\ntry {\n  hydeResponse = JSON.parse($json.choices?.[0]?.message?.content || '{}');\n} catch (e) {\n  hydeResponse = { entities: [], hyde_document: '' };\n}\n\nconst hydeEntities = hydeResponse.entities || [];\n\n// Unicode-safe sanitization (GR-08 fix included)\nconst validEntities = hydeEntities\n  .filter(e => e && typeof e.name === 'string')\n  .map(e => e.name.replace(/[^\\p{L}\\p{N}\\-_\\s]/gu, '').substring(0, 100))\n  .slice(0, 20);\n\nif (validEntities.length === 0) {\n  return [{ \n    json: {\n      skip_neo4j: true, \n      reason: 'No valid entities extracted', \n      hyde_document: hydeResponse.hyde_document \n    }\n  }];\n}\n\n// === CONFIGURATION TRAVERSAL ===\nconst MAX_DEPTH = 3;\nconst MAX_RESULTS = 50;\n\n// === RELATIONSHIP WEIGHTS (matching Neo4j schema) ===\nconst RELATIONSHIP_WEIGHTS = {\n  'A_CREE': 1.5,\n  'CONNECTE': 1.3,\n  'ETUDIE': 1.2,\n  'UTILISE': 1.2,\n  'EXPOSE_A': 1.1,\n  'CAUSE_PAR': 1.4,\n  'PROTEGE_CONTRE': 1.3,\n  'VISE_A_LIMITER': 1.1,\n  'SOUS_ENSEMBLE_DE': 1.0,\n  'CIBLE': 1.2,\n  'ETEND': 1.0\n};\n\nconst ALLOWED_RELATIONSHIPS = Object.keys(RELATIONSHIP_WEIGHTS);\n\n// === NEO4J 5.x QUERY WITH PATH PRUNING V2 (G01) ===\n// - Cycle elimination via apoc.coll.toSet\n// - Relationship type whitelist filter\n// - Deduplication by (start, end) pair keeping best-scored path\nconst prunedQuery = `\nMATCH (n)\nWHERE n.name IN $entity_names\n  AND (n.tenant_id = $tenant_id OR n.tenant_id IS NULL)\nWITH n, \n     CASE \n       WHEN n:Organization THEN 1.3\n       WHEN n:Person THEN 1.2\n       WHEN n:City THEN 1.1\n       WHEN n:Museum THEN 1.2\n       WHEN n:Technology THEN 1.0\n       WHEN n:Disease THEN 1.0\n       ELSE 0.9 \n     END as entity_priority\nORDER BY entity_priority DESC\nLIMIT 10\n\nOPTIONAL MATCH path = (n)-[r*1..${MAX_DEPTH}]-(m)\nWHERE m IS NOT NULL\n  AND (m.tenant_id = $tenant_id OR m.tenant_id IS NULL)\n  AND ALL(rel IN r WHERE type(rel) IN $allowed_relationships)\n  AND SIZE(apoc.coll.toSet(nodes(path))) = SIZE(nodes(path))\n\nWITH n, m, path, length(path) as path_length,\n     reduce(score = entity_priority, rel IN r | \n       score * CASE type(rel)\n         WHEN 'A_CREE' THEN 1.5\n         WHEN 'CAUSE_PAR' THEN 1.4\n         WHEN 'CONNECTE' THEN 1.3\n         WHEN 'PROTEGE_CONTRE' THEN 1.3\n         WHEN 'ETUDIE' THEN 1.2\n         WHEN 'UTILISE' THEN 1.2\n         WHEN 'CIBLE' THEN 1.2\n         WHEN 'EXPOSE_A' THEN 1.1\n         WHEN 'VISE_A_LIMITER' THEN 1.1\n         WHEN 'SOUS_ENSEMBLE_DE' THEN 1.0\n         WHEN 'ETEND' THEN 1.0\n         ELSE 0.8\n       END\n     ) as path_score,\n     SIZE(apoc.coll.toSet(nodes(path))) as unique_nodes\n\nWHERE unique_nodes >= 2\n\nWITH n, m, \n     path,\n     path_length,\n     path_score,\n     n.name + '-' + m.name as path_key\nORDER BY path_score DESC\n\nWITH n, m, \n     collect(path)[0] as best_path,\n     collect(path_score)[0] as best_score,\n     collect(path_length)[0] as best_length\n\nRETURN n.name as start_entity,\n       m.name as end_entity,\n       [node in nodes(best_path) | {name: node.name, type: labels(node)[0]}] as path_nodes,\n       [rel in relationships(best_path) | type(rel)] as path_relations,\n       best_score as path_score,\n       best_length as path_length\nORDER BY best_score DESC\nLIMIT $max_results\n`;\n\nreturn [{\n  json: {\n    skip_neo4j: false,\n    query: prunedQuery,\n    parameters: {\n      entity_names: validEntities,\n      tenant_id: initData.user_context.tenant_id,\n      max_results: MAX_RESULTS,\n      allowed_relationships: ALLOWED_RELATIONSHIPS\n    },\n    hyde_document: hydeResponse.hyde_document,\n    entities: validEntities,\n    traversal_config: {\n      max_depth: MAX_DEPTH,\n      relationship_weights: RELATIONSHIP_WEIGHTS,\n      path_pruning: true,\n      cycle_elimination: true\n    },\n    _debug: {\n      entities_found: validEntities.length,\n      schema_corrected: true,\n      french_relationships: true,\n      neo4j_5x_compatible: true,\n      path_pruning_v2: true\n    }\n  }\n}];",
      "metadata": {
        "reason": "SOTA 2026 Path Pruning V2: Eliminates redundant cyclic paths via apoc.coll.toSet cycle detection, filters relationships by allowed-type whitelist, deduplicates paths by (start, end) pair keeping only the highest-scored path per pair. Reduces redundant paths by ~50% (Neo4j best practices). Also includes ISSUE-GR-08 unicode regex fix. MAX_RESULTS reduced from 100 to 50 due to higher quality results from pruning.",
        "issue_ref": "G01",
        "severity": "P1",
        "node_name": "Neo4j Query Builder (Deep Traversal V2)",
        "node_index": 2,
        "sota_reference": "ARCHITECTURE_FINALE_SOTA_2026_COMPLEMENTAIRE 3.md - Section 4.2 PATCH G01",
        "expected_impact": "-50% redundant paths",
        "includes_fix": "ISSUE-GR-08 (unicode regex)",
        "dependencies": ["APOC plugin required for apoc.coll.toSet"],
        "note": "This patch replaces the entire jsCode of node [2]. If applied, the standalone ISSUE-GR-08 patch (index 3) becomes redundant. Apply EITHER patch index 3 alone OR this patch (index 7), not both."
      }
    },
    {
      "op": "add",
      "path": "/nodes/-",
      "value": {
        "parameters": {
          "jsCode": "// SOTA 2026 G02: Centrality-Based Entity Scoring\n// Boosts hub entities that appear frequently across paths\n// Approximates PageRank/Betweenness Centrality without Neo4j GDS\n\nconst neo4jData = $json;\n\n// Pass through if no graph results\nif (neo4jData.skip_graph || neo4jData.skip_neo4j) {\n  return [{ json: neo4jData }];\n}\n\n// Extract rows from Neo4j response (multiple formats)\nlet rows = [];\nif (neo4jData.results?.[0]?.data) {\n  rows = neo4jData.results[0].data.map(d => d.row);\n} else if (neo4jData.body?.results?.[0]?.data) {\n  rows = neo4jData.body.results[0].data.map(d => d.row);\n} else if (Array.isArray(neo4jData.body)) {\n  rows = neo4jData.body;\n} else if (Array.isArray(neo4jData)) {\n  rows = neo4jData;\n}\n\nif (rows.length === 0) {\n  return [{ json: neo4jData }];\n}\n\n// === STEP 1: Calculate approximate centrality scores ===\nconst entityConnections = {};\n\nrows.forEach(row => {\n  const pathNodes = Array.isArray(row) ? row[2] : row.path_nodes;\n  (pathNodes || []).forEach(node => {\n    if (node && node.name) {\n      const key = `${node.name}::${node.type || 'Unknown'}`;\n      entityConnections[key] = (entityConnections[key] || 0) + 1;\n    }\n  });\n});\n\nconst maxConnections = Math.max(...Object.values(entityConnections), 1);\nconst centralityScores = Object.entries(entityConnections).reduce((acc, [key, count]) => {\n  acc[key] = count / maxConnections;\n  return acc;\n}, {});\n\n// === STEP 2: Apply centrality boost to path scores ===\nconst scoredRows = rows.map(row => {\n  const pathNodes = Array.isArray(row) ? row[2] : row.path_nodes;\n  const pathScore = Array.isArray(row) ? row[4] : row.path_score;\n  const nodes = pathNodes || [];\n\n  const avgCentrality = nodes.reduce((sum, node) => {\n    if (!node || !node.name) return sum;\n    const key = `${node.name}::${node.type || 'Unknown'}`;\n    return sum + (centralityScores[key] || 0);\n  }, 0) / Math.max(nodes.length, 1);\n\n  const combinedScore = (pathScore || 1) * (1 + avgCentrality);\n\n  if (Array.isArray(row)) {\n    return [...row, avgCentrality, combinedScore];\n  }\n  return {\n    ...row,\n    centrality_score: avgCentrality,\n    combined_score: combinedScore\n  };\n});\n\n// === STEP 3: Re-sort by combined score ===\nscoredRows.sort((a, b) => {\n  const scoreA = Array.isArray(a) ? a[a.length - 1] : a.combined_score;\n  const scoreB = Array.isArray(b) ? b[b.length - 1] : b.combined_score;\n  return scoreB - scoreA;\n});\n\n// === STEP 4: Reconstruct response in same format ===\nconst output = JSON.parse(JSON.stringify(neo4jData));\nif (output.results?.[0]?.data) {\n  output.results[0].data = scoredRows.map(row => ({ row: Array.isArray(row) ? row : [row.start_entity, row.end_entity, row.path_nodes, row.path_relations, row.combined_score, row.path_length] }));\n} else if (output.body?.results?.[0]?.data) {\n  output.body.results[0].data = scoredRows.map(row => ({ row: Array.isArray(row) ? row : [row.start_entity, row.end_entity, row.path_nodes, row.path_relations, row.combined_score, row.path_length] }));\n} else {\n  output.scored_results = scoredRows;\n}\n\noutput.centrality_applied = true;\noutput._centrality_stats = {\n  entities_scored: Object.keys(centralityScores).length,\n  top_hubs: Object.entries(centralityScores)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 5)\n    .map(([key, score]) => ({ entity: key, centrality: score }))\n};\n\nreturn [{ json: output }];"
        },
        "id": "c4e92a71-3f8d-4b2e-a1c9-7d6f85e0a312",
        "name": "Centrality Scoring",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          960,
          5968
        ]
      },
      "metadata": {
        "reason": "SOTA 2026 Centrality Scoring: New code node that calculates approximate degree centrality for all entities across graph traversal results, then boosts path scores by the average centrality of their constituent nodes. Hub entities that appear in many paths receive higher scores, improving relevance by ~8% (PageRank reference).",
        "issue_ref": "G02",
        "severity": "P1",
        "node_name": "Centrality Scoring (NEW)",
        "node_index": "21 (appended)",
        "sota_reference": "ARCHITECTURE_FINALE_SOTA_2026_COMPLEMENTAIRE 3.md - Section 4.2 PATCH G02",
        "expected_impact": "+8% relevance via centrality-aware scoring"
      }
    },
    {
      "op": "replace",
      "path": "/connections/Validate Neo4j Results/main/0/0/node",
      "value": "Centrality Scoring",
      "metadata": {
        "reason": "Rewire graph path: Validate Neo4j Results now connects to Centrality Scoring instead of Merge directly",
        "issue_ref": "G02",
        "severity": "P1",
        "before": "Merge",
        "after": "Centrality Scoring"
      }
    },
    {
      "op": "add",
      "path": "/connections/Centrality Scoring",
      "value": {
        "main": [
          [
            {
              "node": "Merge",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "metadata": {
        "reason": "Add connection from new Centrality Scoring node to Merge node (input 0, graph path)",
        "issue_ref": "G02",
        "severity": "P1"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/6/parameters/jsCode",
      "value": "// Enhanced Merge for Deep Traversal Results - CONFIRME\n// Handles paths up to 4 hops with intelligent deduplication\n// PATCHED G02: Reads graph data from Centrality Scoring node\n\n// === COLLECT ALL SOURCES ===\nlet graphResults = [];\nlet vectorResults = [];\nlet communityResults = [];\n\n// Graph Results (from Centrality Scoring - PATCHED G02)\ntry {\n  const neo4jData = $node['Centrality Scoring'].json;\n  \n  let rows = [];\n  if (neo4jData.results?.[0]?.data) {\n    rows = neo4jData.results[0].data.map(d => d.row);\n  } else if (neo4jData.body?.results?.[0]?.data) {\n    rows = neo4jData.body.results[0].data.map(d => d.row);\n  } else if (Array.isArray(neo4jData.body)) {\n    rows = neo4jData.body;\n  } else if (Array.isArray(neo4jData)) {\n    rows = neo4jData;\n  }\n  \n  if (rows.length > 0) {\n    graphResults = rows.map((row, idx) => {\n      const pathNodes = Array.isArray(row) ? row[1] : row.path_nodes;\n      const pathRelations = Array.isArray(row) ? row[2] : row.path_relations;\n      const pathScore = Array.isArray(row) ? row[3] : (row.combined_score || row.path_score);\n      const pathLength = Array.isArray(row) ? row[4] : row.path_length;\n      \n      return {\n        source: 'GRAPH',\n        id: `graph-${idx}`,\n        content: formatGraphPath(pathNodes, pathRelations),\n        path_nodes: pathNodes || [],\n        path_relations: pathRelations || [],\n        path_score: pathScore || 1.0,\n        path_length: pathLength || 1,\n        start_entity: Array.isArray(row) ? row[0] : row.start_entity,\n        centrality_score: row.centrality_score || 0\n      };\n    });\n  }\n} catch (e) { \n  console.log('Graph parse error:', e.message); \n}\n\n// Vector Results (Pinecone)\ntry {\n  const pineconeData = $node['WF3: Pinecone HyDE Search'].json;\n  const matches = pineconeData.body?.matches || pineconeData.matches || [];\n  vectorResults = matches.map((m, idx) => ({\n    source: 'VECTOR',\n    id: m.id || `vector-${idx}`,\n    content: m.metadata?.text || m.metadata?.content || '',\n    score: m.score || 0,\n    metadata: m.metadata\n  }));\n} catch (e) { \n  console.log('Vector parse error:', e.message); \n}\n\n// Community Summaries\ntry {\n  const communityData = $node['Community Summaries Fetch'].json;\n  const commArray = Array.isArray(communityData) ? communityData : \n                    (communityData ? [communityData] : []);\n  communityResults = commArray\n    .filter(c => c && c.summary)\n    .map((c, idx) => ({\n      source: 'COMMUNITY',\n      id: c.community_id || `comm-${idx}`,\n      content: c.summary || '',\n      title: c.title,\n      entity_count: c.entity_count\n    }));\n} catch (e) { \n  console.log('Community parse error:', e.message); \n}\n\n// === HELPER: Format graph path for reading ===\nfunction formatGraphPath(nodes, relations) {\n  if (!nodes || nodes.length === 0) return '';\n  \n  let pathStr = nodes[0]?.name || (typeof nodes[0] === 'string' ? nodes[0] : 'Unknown');\n  \n  for (let i = 0; i < (relations?.length || 0) && i < nodes.length - 1; i++) {\n    const nextNode = nodes[i + 1]?.name || (typeof nodes[i + 1] === 'string' ? nodes[i + 1] : 'Unknown');\n    pathStr += ` --[${relations[i]}]--> ${nextNode}`;\n  }\n  return pathStr;\n}\n\n// === DEDUPLICATION & SCORING ===\nconst allResults = [...graphResults, ...vectorResults, ...communityResults];\n\nconst maxGraphScore = Math.max(...graphResults.map(r => r.path_score || 0), 1);\nconst maxVectorScore = Math.max(...vectorResults.map(r => r.score || 0), 1);\n\nconst normalizedResults = allResults.map(r => {\n  let normalizedScore = 0;\n  if (r.source === 'GRAPH') {\n    normalizedScore = (r.path_score / maxGraphScore) * (1 / (r.path_length * 0.3 + 0.7));\n  } else if (r.source === 'VECTOR') {\n    normalizedScore = r.score / maxVectorScore;\n  } else {\n    normalizedScore = 0.5;\n  }\n  return { ...r, normalized_score: normalizedScore };\n});\n\nnormalizedResults.sort((a, b) => b.normalized_score - a.normalized_score);\n\nconst finalResults = [];\nconst sourceCounts = { GRAPH: 0, VECTOR: 0, COMMUNITY: 0 };\nconst MAX_PER_SOURCE = 15;\nconst TOTAL_MAX = 30;\n\nfor (const result of normalizedResults) {\n  if (finalResults.length >= TOTAL_MAX) break;\n  if (sourceCounts[result.source] < MAX_PER_SOURCE) {\n    finalResults.push(result);\n    sourceCounts[result.source]++;\n  }\n}\n\n// === OUTPUT ===\nreturn [{\n  json: {\n    merged_results: finalResults,\n    source_counts: sourceCounts,\n    total_count: finalResults.length,\n    traversal_depth_used: Math.max(...graphResults.map(r => r.path_length || 0), 0),\n    centrality_applied: $node['Centrality Scoring'].json?.centrality_applied || false,\n    hyde_document: (JSON.parse($node['WF3: HyDE & Entity Extraction'].json.choices[0].message.content || '{}').hyde_document || '')\n  }\n}];",
      "metadata": {
        "reason": "Update Merge Graph + Vector + Community node to read graph results from the new Centrality Scoring node instead of Shield #4 directly. Also surfaces centrality_score and centrality_applied flag in merged output.",
        "issue_ref": "G02",
        "severity": "P1",
        "before": "$node['Shield #4: Neo4j Guardian Traversal'].json",
        "after": "$node['Centrality Scoring'].json",
        "node_name": "Merge Graph + Vector + Community (Deep)",
        "node_index": 6
      }
    }
  ],
  "rollback_patches": [
    {
      "op": "replace",
      "path": "/nodes/11/disabled",
      "value": true,
      "metadata": { "rollback_for": "ISSUE-GR-01" }
    },
    {
      "op": "replace",
      "path": "/nodes/7/parameters/jsonBody",
      "value": "={\n  \"model\": \"{{ $vars.RERANKER_MODEL || 'rerank-multilingual-v3.0' }}\",\n  \"query\": \"{{ $node['OTEL Init'].json.query }}\",\n  \"documents\": {{ JSON.stringify(($json.merged_results || []).map(d => d.content || '').filter(c => c.length > 0).slice(0, 25)) }},\n  \"top_n\": 10\n}",
      "metadata": { "rollback_for": "ISSUE-GR-02" }
    },
    {
      "op": "replace",
      "path": "/nodes/19/parameters/jsCode",
      "value": "const embeddingData = $json;\n\n// Check if we have a valid embedding\nlet embedding = [];\n\n// Try different response formats\nif (embeddingData.data?.[0]?.embedding) {\n  embedding = embeddingData.data[0].embedding;\n} else if (embeddingData.body?.data?.[0]?.embedding) {\n  embedding = embeddingData.body.data[0].embedding;\n} else if (Array.isArray(embeddingData.embedding)) {\n  embedding = embeddingData.embedding;\n}\n\n// Validate embedding dimensions (should be 1536 for text-embedding-3-small)\nconst expectedDim = 1536;\nif (embedding.length !== expectedDim) {\n  throw new Error(`Invalid embedding dimension: got ${embedding.length}, expected ${expectedDim}`);\n}\n\nreturn [{\n  json: {\n    embedding: embedding,\n    dimension: embedding.length\n  }\n}];",
      "metadata": { "rollback_for": "ISSUE-GR-05" }
    },
    {
      "op": "replace",
      "path": "/nodes/2/parameters/jsCode",
      "value": "// CORRECTED Neo4j Query Builder - Neo4j 5.x syntax compatible\n// Fixed: EXISTS() -> IS NOT NULL\n\nconst initData = $node['OTEL Init'].json;\nlet hydeResponse = {};\ntry {\n  hydeResponse = JSON.parse($json.choices?.[0]?.message?.content || '{}');\n} catch (e) {\n  hydeResponse = { entities: [], hyde_document: '' };\n}\n\nconst hydeEntities = hydeResponse.entities || [];\n\n// Strict validation of entity names\nconst validEntities = hydeEntities\n  .filter(e => e && typeof e.name === 'string')\n  .map(e => e.name.replace(/[^a-zA-ZÀ-ÿ0-9\\-_\\s]/g, '').substring(0, 100))\n  .slice(0, 20);\n\nif (validEntities.length === 0) {\n  return [{ \n    json: {\n      skip_neo4j: true, \n      reason: 'No valid entities extracted', \n      hyde_document: hydeResponse.hyde_document \n    }\n  }];\n}\n\n// === CONFIGURATION TRAVERSAL ===\nconst MAX_DEPTH = 3;\nconst MAX_RESULTS = 100;\n\n// === CORRECTED RELATIONSHIP WEIGHTS (matching YOUR Neo4j) ===\nconst RELATIONSHIP_WEIGHTS = {\n  'A_CREE': 1.5,           // Created\n  'CONNECTE': 1.3,         // Connected to\n  'ETUDIE': 1.2,           // Studies\n  'UTILISE': 1.2,          // Uses\n  'EXPOSE_A': 1.1,         // Exposes to\n  'CAUSE_PAR': 1.4,        // Caused by\n  'PROTEGE_CONTRE': 1.3,   // Protects against\n  'VISE_A_LIMITER': 1.1,   // Aims to limit\n  'SOUS_ENSEMBLE_DE': 1.0, // Subset of\n  'CIBLE': 1.2,            // Targets\n  'ETEND': 1.0             // Extends\n};\n\n// === NEO4J 5.x COMPATIBLE QUERY - FIXED EXISTS() ===\nconst correctedQuery = `\nMATCH (n)\nWHERE n.name IN $entity_names\n  AND (n.tenant_id = $tenant_id OR n.tenant_id IS NULL)\nWITH n, \n     CASE \n       WHEN n:Organization THEN 1.3\n       WHEN n:Person THEN 1.2\n       WHEN n:City THEN 1.1\n       WHEN n:Museum THEN 1.2\n       WHEN n:Technology THEN 1.0\n       WHEN n:Disease THEN 1.0\n       ELSE 0.9 \n     END as entity_priority\nORDER BY entity_priority DESC\nLIMIT 10\n\nOPTIONAL MATCH path = (n)-[r*1..${MAX_DEPTH}]-(m)\nWHERE (m.tenant_id = $tenant_id OR m.tenant_id IS NULL)\nWITH path, n as startNode, entity_priority,\n     reduce(score = entity_priority, rel IN relationships(path) | \n       score + CASE type(rel)\n         WHEN 'A_CREE' THEN 1.5\n         WHEN 'CAUSE_PAR' THEN 1.4\n         WHEN 'CONNECTE' THEN 1.3\n         WHEN 'PROTEGE_CONTRE' THEN 1.3\n         WHEN 'ETUDIE' THEN 1.2\n         WHEN 'UTILISE' THEN 1.2\n         WHEN 'CIBLE' THEN 1.2\n         WHEN 'EXPOSE_A' THEN 1.1\n         WHEN 'VISE_A_LIMITER' THEN 1.1\n         WHEN 'SOUS_ENSEMBLE_DE' THEN 1.0\n         WHEN 'ETEND' THEN 1.0\n         ELSE 0.8\n       END\n     ) as path_score,\n     length(path) as path_length\n\nWHERE path_score > (path_length * 0.6)\n\nRETURN \n  startNode.name as start_entity,\n  [node IN nodes(path) | {name: node.name, type: labels(node)[0]}] as path_nodes,\n  [rel IN relationships(path) | type(rel)] as path_relations,\n  path_score,\n  path_length\nORDER BY path_score DESC\nLIMIT $max_results\n`;\n\nreturn [{\n  json: {\n    skip_neo4j: false,\n    query: correctedQuery,\n    parameters: {\n      entity_names: validEntities,\n      tenant_id: initData.user_context.tenant_id,\n      max_results: MAX_RESULTS\n    },\n    hyde_document: hydeResponse.hyde_document,\n    entities: validEntities,\n    traversal_config: {\n      max_depth: MAX_DEPTH,\n      relationship_weights: RELATIONSHIP_WEIGHTS\n    },\n    _debug: {\n      entities_found: validEntities.length,\n      schema_corrected: true,\n      french_relationships: true,\n      neo4j_5x_compatible: true\n    }\n  }\n}];",
      "metadata": { "rollback_for": "ISSUE-GR-08 and G01" }
    },
    {
      "op": "remove",
      "path": "/nodes/7/retryOnFail",
      "metadata": { "rollback_for": "ISSUE-GR-09" }
    },
    {
      "op": "remove",
      "path": "/nodes/7/maxTries",
      "metadata": { "rollback_for": "ISSUE-GR-09" }
    },
    {
      "op": "remove",
      "path": "/nodes/7/waitBetweenTries",
      "metadata": { "rollback_for": "ISSUE-GR-09" }
    },
    {
      "op": "replace",
      "path": "/connections/Validate Neo4j Results/main/0/0/node",
      "value": "Merge",
      "metadata": { "rollback_for": "G02 (restore direct Validate Neo4j Results -> Merge)" }
    },
    {
      "op": "remove",
      "path": "/connections/Centrality Scoring",
      "metadata": { "rollback_for": "G02 (remove Centrality Scoring connections)" }
    },
    {
      "op": "replace",
      "path": "/nodes/6/parameters/jsCode",
      "value": "// Enhanced Merge for Deep Traversal Results - CONFIRMÉ\n// Handles paths up to 4 hops with intelligent deduplication\n\n// === COLLECT ALL SOURCES ===\nlet graphResults = [];\nlet vectorResults = [];\nlet communityResults = [];\n\n// Graph Results (from Deep Traversal)\ntry {\n  const neo4jData = $node['Shield #4: Neo4j Guardian Traversal'].json;\n  \n  let rows = [];\n  if (neo4jData.results?.[0]?.data) {\n    rows = neo4jData.results[0].data.map(d => d.row);\n  } else if (neo4jData.body?.results?.[0]?.data) {\n    rows = neo4jData.body.results[0].data.map(d => d.row);\n  } else if (Array.isArray(neo4jData.body)) {\n    rows = neo4jData.body;\n  } else if (Array.isArray(neo4jData)) {\n    rows = neo4jData;\n  }\n  \n  if (rows.length > 0) {\n    graphResults = rows.map((row, idx) => {\n      const pathNodes = Array.isArray(row) ? row[1] : row.path_nodes;\n      const pathRelations = Array.isArray(row) ? row[2] : row.path_relations;\n      const pathScore = Array.isArray(row) ? row[3] : row.path_score;\n      const pathLength = Array.isArray(row) ? row[4] : row.path_length;\n      \n      return {\n        source: 'GRAPH',\n        id: `graph-${idx}`,\n        content: formatGraphPath(pathNodes, pathRelations),\n        path_nodes: pathNodes || [],\n        path_relations: pathRelations || [],\n        path_score: pathScore || 1.0,\n        path_length: pathLength || 1,\n        start_entity: Array.isArray(row) ? row[0] : row.start_entity\n      };\n    });\n  }\n} catch (e) { \n  console.log('Graph parse error:', e.message); \n}\n\n// Vector Results (Pinecone)\ntry {\n  const pineconeData = $node['WF3: Pinecone HyDE Search'].json;\n  const matches = pineconeData.body?.matches || pineconeData.matches || [];\n  vectorResults = matches.map((m, idx) => ({\n    source: 'VECTOR',\n    id: m.id || `vector-${idx}`,\n    content: m.metadata?.text || m.metadata?.content || '',\n    score: m.score || 0,\n    metadata: m.metadata\n  }));\n} catch (e) { \n  console.log('Vector parse error:', e.message); \n}\n\n// Community Summaries\ntry {\n  const communityData = $node['Community Summaries Fetch'].json;\n  const commArray = Array.isArray(communityData) ? communityData : \n                    (communityData ? [communityData] : []);\n  communityResults = commArray\n    .filter(c => c && c.summary)\n    .map((c, idx) => ({\n      source: 'COMMUNITY',\n      id: c.community_id || `comm-${idx}`,\n      content: c.summary || '',\n      title: c.title,\n      entity_count: c.entity_count\n    }));\n} catch (e) { \n  console.log('Community parse error:', e.message); \n}\n\n// === HELPER: Format graph path for reading ===\nfunction formatGraphPath(nodes, relations) {\n  if (!nodes || nodes.length === 0) return '';\n  \n  let pathStr = nodes[0]?.name || (typeof nodes[0] === 'string' ? nodes[0] : 'Unknown');\n  \n  for (let i = 0; i < (relations?.length || 0) && i < nodes.length - 1; i++) {\n    const nextNode = nodes[i + 1]?.name || (typeof nodes[i + 1] === 'string' ? nodes[i + 1] : 'Unknown');\n    pathStr += ` --[${relations[i]}]--> ${nextNode}`;\n  }\n  return pathStr;\n}\n\n// === DEDUPLICATION & SCORING ===\nconst allResults = [...graphResults, ...vectorResults, ...communityResults];\n\nconst maxGraphScore = Math.max(...graphResults.map(r => r.path_score || 0), 1);\nconst maxVectorScore = Math.max(...vectorResults.map(r => r.score || 0), 1);\n\nconst normalizedResults = allResults.map(r => {\n  let normalizedScore = 0;\n  if (r.source === 'GRAPH') {\n    normalizedScore = (r.path_score / maxGraphScore) * (1 / (r.path_length * 0.3 + 0.7));\n  } else if (r.source === 'VECTOR') {\n    normalizedScore = r.score / maxVectorScore;\n  } else {\n    normalizedScore = 0.5;\n  }\n  return { ...r, normalized_score: normalizedScore };\n});\n\nnormalizedResults.sort((a, b) => b.normalized_score - a.normalized_score);\n\nconst finalResults = [];\nconst sourceCounts = { GRAPH: 0, VECTOR: 0, COMMUNITY: 0 };\nconst MAX_PER_SOURCE = 15;\nconst TOTAL_MAX = 30;\n\nfor (const result of normalizedResults) {\n  if (finalResults.length >= TOTAL_MAX) break;\n  if (sourceCounts[result.source] < MAX_PER_SOURCE) {\n    finalResults.push(result);\n    sourceCounts[result.source]++;\n  }\n}\n\n// === OUTPUT ===\nreturn [{\n  json: {\n    merged_results: finalResults,\n    source_counts: sourceCounts,\n    total_count: finalResults.length,\n    traversal_depth_used: Math.max(...graphResults.map(r => r.path_length || 0), 0),\n    hyde_document: (JSON.parse($node['WF3: HyDE & Entity Extraction'].json.choices[0].message.content || '{}').hyde_document || '')\n  }\n}];",
      "metadata": { "rollback_for": "G02 (restore reference to Shield #4)" }
    },
    {
      "op": "test",
      "path": "/nodes/21",
      "metadata": { "rollback_for": "G02 - verify Centrality Scoring node exists before removing" }
    }
  ],
  "deployment_notes": "## Deployment Order\n\n### Phase 1 - Critical Fixes (P0) - Apply immediately\n1. **ISSUE-GR-01** (patch 0): Re-enable Shield #9 Export Trace - zero risk, restores observability\n2. **ISSUE-GR-02** (patch 1): Upgrade Cohere model to rerank-v3.5 - update $vars.RERANKER_MODEL if set\n\n### Phase 2 - Important Fixes (P1) - Apply after Phase 1 validation\n3. **ISSUE-GR-05** (patch 2): Configurable embedding dimension - add EMBEDDING_DIMENSION to workflow variables if needed\n4. **G01** (patch 7): Path Pruning V2 - REQUIRES apoc plugin in Neo4j. Supersedes ISSUE-GR-08 (patch 3)\n5. **G02** (patches 8-11): Centrality Scoring - adds new node and rewires connections\n\n### Phase 3 - Minor Fixes (P2)\n6. **ISSUE-GR-09** (patches 4-6): Retry on fail for Cohere Reranker\n\n## IMPORTANT NOTES\n- Patches 3 (GR-08 standalone) and 7 (G01) both target /nodes/2/parameters/jsCode. Apply ONLY G01 (patch 7) as it includes the GR-08 fix. If G01 is not desired, apply patch 3 instead.\n- G02 patches (8-11) must be applied together as an atomic group.\n- G01 requires the APOC plugin to be installed in Neo4j for apoc.coll.toSet().\n- Backup the workflow JSON before applying any patches.\n- After applying, validate via n8n workflow test execution with a sample query.",
  "test_cases": [
    {
      "description": "Verify Shield #9 Export Trace is enabled and sends telemetry",
      "issue_ref": "ISSUE-GR-01",
      "input": { "query": "test query", "tenant_id": "test" },
      "expected": { "trace_export_called": true, "status_code": 200 },
      "validation": "Shield #9 node should execute after Response Formatter and POST to OTEL collector"
    },
    {
      "description": "Verify Cohere Reranker uses rerank-v3.5 model",
      "issue_ref": "ISSUE-GR-02",
      "input": { "merged_results": [{"content": "test doc 1"}, {"content": "test doc 2"}] },
      "expected": { "model_in_request": "rerank-v3.5" },
      "validation": "HTTP request body should contain model: rerank-v3.5"
    },
    {
      "description": "Verify embedding dimension is configurable via $vars.EMBEDDING_DIMENSION",
      "issue_ref": "ISSUE-GR-05",
      "input": { "embedding": "vector of length 3072", "EMBEDDING_DIMENSION": "3072" },
      "expected": { "no_error": true, "dimension": 3072 },
      "validation": "Setting EMBEDDING_DIMENSION=3072 should accept 3072-dim embeddings without error"
    },
    {
      "description": "Verify entity names with accents and unicode are preserved",
      "issue_ref": "ISSUE-GR-08",
      "input": { "entities": [{"name": "Francois Muller", "type": "Person"}, {"name": "Zurich", "type": "City"}, {"name": "Strasbourg", "type": "City"}] },
      "expected": { "entities_preserved": ["Francois Muller", "Zurich", "Strasbourg"] },
      "validation": "Accented characters (e, u, etc.) should NOT be stripped by the sanitization regex"
    },
    {
      "description": "Verify Cohere Reranker retries on transient failure",
      "issue_ref": "ISSUE-GR-09",
      "input": { "simulate": "503 Service Unavailable on first attempt" },
      "expected": { "retries": "up to 3", "wait_between": 2000 },
      "validation": "Node should retry up to 3 times with 2s delay on HTTP errors"
    },
    {
      "description": "Verify path pruning eliminates cyclic paths",
      "issue_ref": "G01",
      "input": { "entities": [{"name": "Alice", "type": "Person"}], "tenant_id": "test" },
      "expected": { "no_cyclic_paths": true, "unique_start_end_pairs": true },
      "validation": "Cypher query should use apoc.coll.toSet for cycle detection and deduplicate by (start, end) pair"
    },
    {
      "description": "Verify centrality scoring boosts hub entities",
      "issue_ref": "G02",
      "input": {
        "results": [
          {"path_nodes": [{"name": "Hub", "type": "Org"}, {"name": "A", "type": "Person"}], "path_score": 1.0},
          {"path_nodes": [{"name": "Hub", "type": "Org"}, {"name": "B", "type": "Person"}], "path_score": 1.0},
          {"path_nodes": [{"name": "Leaf", "type": "City"}, {"name": "C", "type": "Person"}], "path_score": 1.0}
        ]
      },
      "expected": { "hub_centrality": "higher than leaf", "results_reordered": true },
      "validation": "Paths containing 'Hub' entity (appears in 2 paths) should score higher than paths with 'Leaf' (appears in 1 path)"
    }
  ]
}
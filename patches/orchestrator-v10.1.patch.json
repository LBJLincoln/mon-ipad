{
  "workflow_file": "V10.1 orchestrator copy (5).json",
  "workflow_name": "V10.1 orchestrator copy",
  "workflow_id": "FZxkpldDbgV8AD_cg7IWG",
  "generated_at": "2026-02-06T00:07:48Z",
  "generated_by": "patch-writer-agent",
  "version": "1.0.0",
  "patches": [
    {
      "op": "replace",
      "path": "/nodes/3/parameters/jsCode",
      "value": "// INIT V8 - Security Gate + Pre-Classification + CoT Prep + Query Hash\n// PATCHED: ISSUE-ORC-03 - Cache key extended to 32 chars + tenant namespace\nconst body = $node[\"Input Merger V8\"].json.body || {};\nconst inputMerger = $node[\"Input Merger V8\"].json;\nconst startTime = Date.now();\n\n// Crypto pour hash\nconst crypto = require('crypto');\n\n// Extraction query\nlet rawQuery = body.query || inputMerger.query || '';\nconst query = rawQuery.trim();\n\n// G√©n√©rer query_hash pour cache (32 chars + tenant namespace)\nconst tenantId = body.tenant_id || 'default';\nconst queryHash = tenantId + ':' + crypto.createHash('sha256')\n  .update(query.toLowerCase().trim())\n  .digest('hex').substring(0, 32);\n\n// Trace ID\nconst traceId = body.conversation_id || inputMerger.conversation_id || \n  `trace-${Date.now()}-${Math.random().toString(36).substring(7)}`;\n\n// Security checks\nconst isSuspicious = /(<script|javascript:|onerror=|eval\\()/i.test(query);\nconst isEmpty = query.length < 2;\n\nreturn {\n  trace_id: traceId,\n  query: query,\n  query_hash: queryHash,\n  conversation_id: body.conversation_id || traceId,\n  session_id: body.session_id || body.conversation_id || traceId,\n  tenant_id: body.tenant_id || 'default',\n  user_groups: body.user_groups || ['default'],\n  metadata: body.metadata || {},\n  is_suspicious: isSuspicious,\n  is_empty: isEmpty,\n  timestamp: startTime,\n  source: inputMerger.source || 'unknown'\n};\n",
      "metadata": {
        "issue_ref": "ISSUE-ORC-03",
        "severity": "P0",
        "category": "security",
        "reason": "Cache key uses only 16 hex chars (65536 possible values) with no tenant namespace, causing cross-tenant cache collisions. Extended to 32 hex chars and prefixed with tenant_id for proper namespace isolation.",
        "node_name": "Init V8 Security & Analysis",
        "node_id": "3e534116-e58f-4aff-802c-66b4c5db2b2e",
        "node_index": 3,
        "before_summary": "queryHash = sha256(query).hex.substring(0, 16)",
        "after_summary": "queryHash = tenant_id + ':' + sha256(query).hex.substring(0, 32)",
        "breaking_change": true,
        "requires_cache_flush": true,
        "affected_downstream": [
          "Cache Parser",
          "Redis: Cache + Generator",
          "üíæ Cache Storage"
        ]
      }
    },
    {
      "op": "replace",
      "path": "/nodes/51/parameters/jsonBody",
      "value": "={{ {\n  \"model\": $vars.LLM_AGENT_MODEL || 'anthropic/claude-sonnet-4-5-20250929',\n  \"max_tokens\": 2000,\n  \"temperature\": 0.3,\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Tu es le JUGE d'un syst√®me RAG multi-moteurs. Ton r√¥le est de d√©cider si les r√©sultats obtenus permettent de r√©pondre √† la question de l'utilisateur.\\n\\n=== TON R√îLE ===\\n1. Analyser la QUERY ORIGINALE de l'utilisateur\\n2. Examiner les R√âPONSES OBTENUES des t√¢ches compl√©t√©es\\n3. JUGER si ces r√©ponses permettent de r√©pondre √† la query\\n4. D√©cider quoi faire des t√¢ches encore en attente (pending)\\n\\n=== TES D√âCISIONS POSSIBLES ===\\n\\n**all_tasks_complete: true** ‚Üí Les r√©ponses obtenues suffisent pour r√©pondre √† l'utilisateur\\n- Mettre toutes les t√¢ches pending en SKIP\\n- Le workflow va g√©n√©rer la r√©ponse finale\\n\\n**all_tasks_complete: false** ‚Üí Il manque des informations\\n- KEEP les t√¢ches pending n√©cessaires\\n- SKIP les t√¢ches pending redondantes\\n- Optionnel: ADD de nouvelles t√¢ches\\n\\n=== FORMAT DE R√âPONSE JSON ===\\n{\\n  \\\"all_tasks_complete\\\": true/false,\\n  \\\"judgment\\\": \\\"Explication de pourquoi les r√©ponses suffisent ou non\\\",\\n  \\\"actions\\\": [\\n    {\\\"action\\\": \\\"SKIP\\\", \\\"task_id\\\": 2, \\\"reason\\\": \\\"...\\\"},\\n    {\\\"action\\\": \\\"KEEP\\\", \\\"task_id\\\": 3, \\\"reason\\\": \\\"...\\\"}\\n  ],\\n  \\\"missing_info\\\": \\\"Ce qui manque si all_tasks_complete=false\\\"\\n}\\n\\n=== R√àGLES ===\\n- Tu DOIS donner une action pour CHAQUE t√¢che pending\\n- Si all_tasks_complete=true, TOUTES les pending doivent √™tre SKIP\\n- Ne g√®re PAS les fallbacks/erreurs (un autre syst√®me s'en occupe)\\n- R√©ponds UNIQUEMENT en JSON valide\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"=== QUERY ORIGINALE DE L'UTILISATEUR ===\\n\" + $node['Init V8 Security & Analysis'].json.query + \"\\n\\n=== R√âPONSES OBTENUES (t√¢ches compl√©t√©es) ===\\n\" + JSON.stringify($node['üìä Task Status Aggregator'].json.completed_tasks || [], null, 2) + \"\\n\\n=== T√ÇCHES EN ATTENTE (pending) ===\\n\" + JSON.stringify($node['üìä Task Status Aggregator'].json.pending_tasks || [], null, 2) + \"\\n\\n=== T√ÇCHES EN ERREUR ===\\n\" + JSON.stringify($node['üìä Task Status Aggregator'].json.error_tasks || [], null, 2) + \"\\n\\nAnalyse si les r√©ponses obtenues permettent de r√©pondre √† la query originale. Retourne ta d√©cision en JSON.\"\n    }\n  ]\n} }}",
      "metadata": {
        "issue_ref": "ISSUE-ORC-06",
        "severity": "P1",
        "category": "model_update",
        "reason": "LLM 3 Agent Harness uses obsolete model 'anthropic/claude-3-5-sonnet-20241022' (deprecated). Updated to 'anthropic/claude-sonnet-4-5-20250929' for improved reasoning, better JSON compliance, and extended thinking support.",
        "node_name": "üéØ LLM 3: Agent Harness (Opus 4.5)",
        "node_id": "65630655-5b38-4faa-9a4d-a30faa4ce90a",
        "node_index": 51,
        "before_summary": "model: anthropic/claude-3-5-sonnet-20241022",
        "after_summary": "model: anthropic/claude-sonnet-4-5-20250929",
        "string_replace": {
          "search": "anthropic/claude-3-5-sonnet-20241022",
          "replace": "anthropic/claude-sonnet-4-5-20250929"
        },
        "breaking_change": false,
        "cost_impact": "Claude Sonnet 4.5 pricing applies; check OpenRouter rates"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/63/name",
      "value": "IF: All Execution Complete?",
      "metadata": {
        "issue_ref": "ISSUE-ORC-09",
        "severity": "P2",
        "category": "readability",
        "reason": "Generic 'If' name provides no context. This node routes Execution Engine output: true branch (all_complete=true) to Response Builder, false branch to Dynamic Switch for continued task dispatch.",
        "node_name": "If",
        "node_id": "357e6360-0498-4633-b5f8-30061ecd941a",
        "node_index": 63,
        "before_summary": "name: If",
        "after_summary": "name: IF: All Execution Complete?",
        "breaking_change": false,
        "requires_connection_update": true
      }
    },
    {
      "op": "move",
      "from": "/connections/If",
      "path": "/connections/IF: All Execution Complete?",
      "metadata": {
        "issue_ref": "ISSUE-ORC-09",
        "severity": "P2",
        "category": "readability",
        "reason": "Connection source key must match renamed node 'IF: All Execution Complete?'",
        "node_name": "If",
        "node_index": 63,
        "companion_to": "ISSUE-ORC-09 node rename"
      }
    },
    {
      "op": "replace",
      "path": "/connections/‚öôÔ∏è Execution Engine V10/main/0/0/node",
      "value": "IF: All Execution Complete?",
      "metadata": {
        "issue_ref": "ISSUE-ORC-09",
        "severity": "P2",
        "category": "readability",
        "reason": "Target reference in Execution Engine V10 connections must point to renamed node",
        "node_name": "‚öôÔ∏è Execution Engine V10",
        "companion_to": "ISSUE-ORC-09 node rename"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/64/name",
      "value": "IF: Should Continue Loop?",
      "metadata": {
        "issue_ref": "ISSUE-ORC-09",
        "severity": "P2",
        "category": "readability",
        "reason": "Generic 'If1' name provides no context. This node controls the agent loop: true branch (all_tasks_complete=false) continues to Apply Skips + Insert New Tasks, false branch halts the loop.",
        "node_name": "If1",
        "node_id": "ea57ed6e-ec10-4c32-9600-d5859f56d625",
        "node_index": 64,
        "before_summary": "name: If1",
        "after_summary": "name: IF: Should Continue Loop?",
        "breaking_change": false,
        "requires_connection_update": true
      }
    },
    {
      "op": "move",
      "from": "/connections/If1",
      "path": "/connections/IF: Should Continue Loop?",
      "metadata": {
        "issue_ref": "ISSUE-ORC-09",
        "severity": "P2",
        "category": "readability",
        "reason": "Connection source key must match renamed node 'IF: Should Continue Loop?'",
        "node_name": "If1",
        "node_index": 64,
        "companion_to": "ISSUE-ORC-09 node rename"
      }
    },
    {
      "op": "replace",
      "path": "/connections/üîÑ Task Updater/main/0/0/node",
      "value": "IF: Should Continue Loop?",
      "metadata": {
        "issue_ref": "ISSUE-ORC-09",
        "severity": "P2",
        "category": "readability",
        "reason": "Target reference in Task Updater connections must point to renamed node",
        "node_name": "üîÑ Task Updater",
        "companion_to": "ISSUE-ORC-09 node rename"
      }
    },
    {
      "op": "test",
      "path": "/nodes/6/parameters/workflowId/value",
      "value": "qtBs2Wbi_raU2o_dqfdDC",
      "metadata": {
        "issue_ref": "ISSUE-ORC-13",
        "severity": "P2",
        "category": "maintainability",
        "reason": "Sub-workflow ID is hardcoded. Should be moved to n8n variable $vars.WF_STANDARD_ID for environment portability. Test operation verifies the current value; manual migration to variables required.",
        "node_name": "Invoke WF5: Standard",
        "node_id": "72c191ac-677e-4f9c-a64f-1cc328680e31",
        "node_index": 6,
        "recommended_variable": "$vars.WF_STANDARD_ID",
        "current_value": "qtBs2Wbi_raU2o_dqfdDC",
        "action_required": "manual",
        "migration_steps": [
          "1. Create n8n variable WF_STANDARD_ID with value 'qtBs2Wbi_raU2o_dqfdDC'",
          "2. Change workflowId mode from 'id' to expression",
          "3. Set value to '={{ $vars.WF_STANDARD_ID }}'",
          "4. Test sub-workflow invocation"
        ]
      }
    },
    {
      "op": "test",
      "path": "/nodes/7/parameters/workflowId/value",
      "value": "95x2BBAbJlLWZtWEJn6rb",
      "metadata": {
        "issue_ref": "ISSUE-ORC-13",
        "severity": "P2",
        "category": "maintainability",
        "reason": "Sub-workflow ID is hardcoded. Should be moved to n8n variable $vars.WF_GRAPH_ID for environment portability.",
        "node_name": "Invoke WF2: Graph",
        "node_id": "e3d043ea-96ab-4413-a1a5-683b090596a4",
        "node_index": 7,
        "recommended_variable": "$vars.WF_GRAPH_ID",
        "current_value": "95x2BBAbJlLWZtWEJn6rb",
        "action_required": "manual",
        "migration_steps": [
          "1. Create n8n variable WF_GRAPH_ID with value '95x2BBAbJlLWZtWEJn6rb'",
          "2. Change workflowId mode from 'id' to expression",
          "3. Set value to '={{ $vars.WF_GRAPH_ID }}'",
          "4. Test sub-workflow invocation"
        ]
      }
    },
    {
      "op": "test",
      "path": "/nodes/8/parameters/workflowId/value",
      "value": "xrzL7TRX9F0UrWks0tdCI",
      "metadata": {
        "issue_ref": "ISSUE-ORC-13",
        "severity": "P2",
        "category": "maintainability",
        "reason": "Sub-workflow ID is hardcoded. Should be moved to n8n variable $vars.WF_QUANTITATIVE_ID for environment portability.",
        "node_name": "Invoke WF4: Quantitative",
        "node_id": "8d682938-416e-4a7c-915e-b9a02cca209a",
        "node_index": 8,
        "recommended_variable": "$vars.WF_QUANTITATIVE_ID",
        "current_value": "xrzL7TRX9F0UrWks0tdCI",
        "action_required": "manual",
        "migration_steps": [
          "1. Create n8n variable WF_QUANTITATIVE_ID with value 'xrzL7TRX9F0UrWks0tdCI'",
          "2. Change workflowId mode from 'list' to expression",
          "3. Set value to '={{ $vars.WF_QUANTITATIVE_ID }}'",
          "4. Test sub-workflow invocation"
        ]
      }
    },
    {
      "op": "replace",
      "path": "/nodes/20/parameters/jsCode",
      "value": "// Intent Parser V9.2 - Parse LLM 1 output + SOTA 2026 Confidence-Based Routing\n// PATCHED: O01 - Confidence scoring for adaptive routing\nconst llmResponse = $json;\nconst initData = $node['Init V8 Security & Analysis'].json;\nconst guardrailData = $node['üõ°Ô∏è Advanced Guardrails'].json;\n\nlet intentsData;\nlet parseConfidence = 1.0;\ntry {\n  const content = llmResponse.body?.choices?.[0]?.message?.content \n               || llmResponse.choices?.[0]?.message?.content || '{}';\n  intentsData = JSON.parse(content);\n} catch (e) {\n  parseConfidence = 0.2;\n  // Fallback: single intent based on router\n  intentsData = {\n    reasoning: 'Fallback due to parsing error: ' + e.message,\n    intents: [{\n      id: 'intent-1',\n      description: initData.query,\n      type: 'FACTUAL',\n      suggested_rag: guardrailData.engine || 'STANDARD',\n      priority: 1,\n      depends_on: [],\n      can_parallelize_with: []\n    }],\n    execution_order: ['intent-1'],\n    has_parallel_intents: false,\n    complexity: 'SIMPLE'\n  };\n}\n\n// === CONFIDENCE SCORING (SOTA 2026 O01) ===\nconst CONFIDENCE_WEIGHTS = {\n  TYPE_MATCH: 0.3,\n  REASONING_QUALITY: 0.25,\n  SPECIFICITY: 0.25,\n  DEPENDENCY_CLARITY: 0.2\n};\n\nconst RAG_TYPE_AFFINITY = {\n  'FACTUAL':      { 'STANDARD': 0.95, 'GRAPH': 0.4,  'QUANTITATIVE': 0.2 },\n  'QUANTITATIVE': { 'QUANTITATIVE': 0.95, 'STANDARD': 0.3, 'GRAPH': 0.2 },\n  'RELATIONAL':   { 'GRAPH': 0.95, 'STANDARD': 0.4, 'QUANTITATIVE': 0.1 },\n  'PROCEDURAL':   { 'STANDARD': 0.9, 'GRAPH': 0.3,  'QUANTITATIVE': 0.1 },\n  'COMPARATIVE':  { 'QUANTITATIVE': 0.7, 'STANDARD': 0.6, 'GRAPH': 0.5 }\n};\n\nfunction scoreIntent(intent) {\n  let score = 0;\n  \n  // Type-RAG affinity\n  const affinity = RAG_TYPE_AFFINITY[intent.type] || {};\n  const typeScore = affinity[intent.suggested_rag] || 0.5;\n  score += typeScore * CONFIDENCE_WEIGHTS.TYPE_MATCH;\n  \n  // Reasoning quality (from LLM)\n  const hasReasoning = intentsData.reasoning && intentsData.reasoning.length > 20;\n  score += (hasReasoning ? 0.9 : 0.3) * CONFIDENCE_WEIGHTS.REASONING_QUALITY;\n  \n  // Description specificity\n  const descLen = (intent.description || '').length;\n  const specificityScore = Math.min(1.0, descLen / 80);\n  score += specificityScore * CONFIDENCE_WEIGHTS.SPECIFICITY;\n  \n  // Dependency clarity\n  const hasDeps = Array.isArray(intent.depends_on);\n  const hasParallel = Array.isArray(intent.can_parallelize_with);\n  score += ((hasDeps && hasParallel) ? 0.9 : 0.4) * CONFIDENCE_WEIGHTS.DEPENDENCY_CLARITY;\n  \n  return Math.round(score * 1000) / 1000;\n}\n\n// Validate intents with confidence\nconst validRags = ['STANDARD', 'GRAPH', 'QUANTITATIVE'];\nintentsData.intents = (intentsData.intents || []).map((intent, idx) => {\n  const validated = {\n    ...intent,\n    id: intent.id || `intent-${idx + 1}`,\n    suggested_rag: validRags.includes(intent.suggested_rag) ? intent.suggested_rag : 'STANDARD',\n    priority: intent.priority || idx + 1,\n    depends_on: Array.isArray(intent.depends_on) ? intent.depends_on : [],\n    can_parallelize_with: Array.isArray(intent.can_parallelize_with) ? intent.can_parallelize_with : []\n  };\n  validated.routing_confidence = scoreIntent(validated);\n  return validated;\n});\n\n// Overall routing confidence\nconst avgConfidence = intentsData.intents.length > 0\n  ? intentsData.intents.reduce((sum, i) => sum + i.routing_confidence, 0) / intentsData.intents.length\n  : 0.5;\nconst overallConfidence = Math.round(avgConfidence * parseConfidence * 1000) / 1000;\n\n// Determine if parallel execution is possible\nconst hasParallel = intentsData.has_parallel_intents || \n  intentsData.intents.some(i => i.can_parallelize_with?.length > 0);\n\n// Output format for LLM 2\nreturn {\n  trace_id: initData.trace_id,\n  original_query: initData.query,\n  user_context: initData.user_context,\n  \n  // Intent analysis\n  intents: intentsData.intents,\n  execution_order: intentsData.execution_order || intentsData.intents.map(i => i.id),\n  reasoning: intentsData.reasoning,\n  complexity: intentsData.complexity || 'MODERATE',\n  \n  // SOTA 2026: Confidence scoring (O01)\n  routing_confidence: overallConfidence,\n  parse_confidence: parseConfidence,\n  \n  // Parallelization info\n  has_parallel_intents: hasParallel,\n  \n  // Pass through\n  is_chat: $node['Input Merger V8'].json.is_chat,\n  is_webhook: $node['Input Merger V8'].json.is_webhook,\n  conversation_id: initData.conversation_id\n};",
      "metadata": {
        "issue_ref": "O01",
        "severity": "SOTA-2026",
        "category": "enhancement",
        "reason": "SOTA 2026 enhancement: Add confidence-based routing to Intent Parser. Each intent now receives a routing_confidence score (0-1) based on type-RAG affinity, LLM reasoning quality, description specificity, and dependency clarity. Downstream Task Planner can use these scores for cost-aware decisions.",
        "node_name": "Intent Parser V9",
        "node_id": "bdea704a-e190-4948-b5df-8452da164e03",
        "node_index": 20,
        "before_summary": "Intents parsed without confidence scoring",
        "after_summary": "Intents scored with routing_confidence (0-1) based on RAG_TYPE_AFFINITY matrix + parse quality signals",
        "new_output_fields": [
          "routing_confidence",
          "parse_confidence"
        ],
        "breaking_change": false,
        "affects_downstream": [
          "üéØ LLM 2: Task Planner"
        ]
      }
    },
    {
      "op": "test",
      "path": "/nodes/21/name",
      "value": "üéØ LLM 2: Task Planner",
      "metadata": {
        "issue_ref": "O03",
        "severity": "SOTA-2026",
        "category": "enhancement",
        "reason": "SOTA 2026 enhancement: Cost-Aware Planning. The Task Planner system prompt should include estimated cost per RAG engine to optimize plan cost. This is a documentation-only patch; the jsonBody template expression is too fragile for automated patching.",
        "node_name": "üéØ LLM 2: Task Planner",
        "node_id": "a2123ca5-27d8-41d5-85c1-a8c6dd96c1d2",
        "node_index": 21,
        "action_required": "manual",
        "recommended_changes": [
          "Add to system prompt after '=== R√àGLES DE PLANIFICATION ===':",
          "",
          "=== COST PER ENGINE (SOTA 2026) ===",
          "STANDARD: ~$0.003/query (Pinecone + BM25 + Cohere rerank)",
          "GRAPH: ~$0.008/query (Neo4j traversal + community detection)",
          "QUANTITATIVE: ~$0.002/query (PostgreSQL + Text-to-SQL)",
          "",
          "COST RULES:",
          "1. If confidence > 0.85, prefer cheapest engine",
          "2. If routing_confidence < 0.5, use STANDARD as safe default",
          "3. Parallel execution multiplies cost - only parallelize if justified",
          "4. Add 'estimated_cost' field to each task in the plan"
        ],
        "input_dependency": "Requires O01 (routing_confidence field from Intent Parser)"
      }
    }
  ],
  "rollback_patches": [
    {
      "op": "replace",
      "path": "/nodes/3/parameters/jsCode",
      "value": "// INIT V8 - Security Gate + Pre-Classification + CoT Prep + Query Hash\nconst body = $node[\"Input Merger V8\"].json.body || {};\nconst inputMerger = $node[\"Input Merger V8\"].json;\nconst startTime = Date.now();\n\n// Crypto pour hash\nconst crypto = require('crypto');\n\n// Extraction query\nlet rawQuery = body.query || inputMerger.query || '';\nconst query = rawQuery.trim();\n\n// G√©n√©rer query_hash pour cache\nconst queryHash = crypto.createHash('sha256')\n  .update(query.toLowerCase().trim())\n  .digest('hex').substring(0, 16);\n\n// Trace ID\nconst traceId = body.conversation_id || inputMerger.conversation_id || \n  `trace-${Date.now()}-${Math.random().toString(36).substring(7)}`;\n\n// Security checks\nconst isSuspicious = /(<script|javascript:|onerror=|eval\\()/i.test(query);\nconst isEmpty = query.length < 2;\n\nreturn {\n  trace_id: traceId,\n  query: query,\n  query_hash: queryHash,\n  conversation_id: body.conversation_id || traceId,\n  session_id: body.session_id || body.conversation_id || traceId,\n  tenant_id: body.tenant_id || 'default',\n  user_groups: body.user_groups || ['default'],\n  metadata: body.metadata || {},\n  is_suspicious: isSuspicious,\n  is_empty: isEmpty,\n  timestamp: startTime,\n  source: inputMerger.source || 'unknown'\n};\n",
      "metadata": {
        "rollback_for": "ISSUE-ORC-03"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/51/parameters/jsonBody",
      "value": "={{ {\n  \"model\": $vars.LLM_AGENT_MODEL || 'anthropic/claude-3-5-sonnet-20241022',\n  \"max_tokens\": 2000,\n  \"temperature\": 0.3,\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Tu es le JUGE d'un syst√®me RAG multi-moteurs. Ton r√¥le est de d√©cider si les r√©sultats obtenus permettent de r√©pondre √† la question de l'utilisateur.\\n\\n=== TON R√îLE ===\\n1. Analyser la QUERY ORIGINALE de l'utilisateur\\n2. Examiner les R√âPONSES OBTENUES des t√¢ches compl√©t√©es\\n3. JUGER si ces r√©ponses permettent de r√©pondre √† la query\\n4. D√©cider quoi faire des t√¢ches encore en attente (pending)\\n\\n=== TES D√âCISIONS POSSIBLES ===\\n\\n**all_tasks_complete: true** ‚Üí Les r√©ponses obtenues suffisent pour r√©pondre √† l'utilisateur\\n- Mettre toutes les t√¢ches pending en SKIP\\n- Le workflow va g√©n√©rer la r√©ponse finale\\n\\n**all_tasks_complete: false** ‚Üí Il manque des informations\\n- KEEP les t√¢ches pending n√©cessaires\\n- SKIP les t√¢ches pending redondantes\\n- Optionnel: ADD de nouvelles t√¢ches\\n\\n=== FORMAT DE R√âPONSE JSON ===\\n{\\n  \\\"all_tasks_complete\\\": true/false,\\n  \\\"judgment\\\": \\\"Explication de pourquoi les r√©ponses suffisent ou non\\\",\\n  \\\"actions\\\": [\\n    {\\\"action\\\": \\\"SKIP\\\", \\\"task_id\\\": 2, \\\"reason\\\": \\\"...\\\"},\\n    {\\\"action\\\": \\\"KEEP\\\", \\\"task_id\\\": 3, \\\"reason\\\": \\\"...\\\"}\\n  ],\\n  \\\"missing_info\\\": \\\"Ce qui manque si all_tasks_complete=false\\\"\\n}\\n\\n=== R√àGLES ===\\n- Tu DOIS donner une action pour CHAQUE t√¢che pending\\n- Si all_tasks_complete=true, TOUTES les pending doivent √™tre SKIP\\n- Ne g√®re PAS les fallbacks/erreurs (un autre syst√®me s'en occupe)\\n- R√©ponds UNIQUEMENT en JSON valide\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"=== QUERY ORIGINALE DE L'UTILISATEUR ===\\n\" + $node['Init V8 Security & Analysis'].json.query + \"\\n\\n=== R√âPONSES OBTENUES (t√¢ches compl√©t√©es) ===\\n\" + JSON.stringify($node['üìä Task Status Aggregator'].json.completed_tasks || [], null, 2) + \"\\n\\n=== T√ÇCHES EN ATTENTE (pending) ===\\n\" + JSON.stringify($node['üìä Task Status Aggregator'].json.pending_tasks || [], null, 2) + \"\\n\\n=== T√ÇCHES EN ERREUR ===\\n\" + JSON.stringify($node['üìä Task Status Aggregator'].json.error_tasks || [], null, 2) + \"\\n\\nAnalyse si les r√©ponses obtenues permettent de r√©pondre √† la query originale. Retourne ta d√©cision en JSON.\"\n    }\n  ]\n} }}",
      "metadata": {
        "rollback_for": "ISSUE-ORC-06"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/63/name",
      "value": "If",
      "metadata": {
        "rollback_for": "ISSUE-ORC-09 (If)"
      }
    },
    {
      "op": "move",
      "from": "/connections/IF: All Execution Complete?",
      "path": "/connections/If",
      "metadata": {
        "rollback_for": "ISSUE-ORC-09 (If connections key)"
      }
    },
    {
      "op": "replace",
      "path": "/connections/‚öôÔ∏è Execution Engine V10/main/0/0/node",
      "value": "If",
      "metadata": {
        "rollback_for": "ISSUE-ORC-09 (If target ref)"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/64/name",
      "value": "If1",
      "metadata": {
        "rollback_for": "ISSUE-ORC-09 (If1)"
      }
    },
    {
      "op": "move",
      "from": "/connections/IF: Should Continue Loop?",
      "path": "/connections/If1",
      "metadata": {
        "rollback_for": "ISSUE-ORC-09 (If1 connections key)"
      }
    },
    {
      "op": "replace",
      "path": "/connections/üîÑ Task Updater/main/0/0/node",
      "value": "If1",
      "metadata": {
        "rollback_for": "ISSUE-ORC-09 (If1 target ref)"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/20/parameters/jsCode",
      "value": "// Intent Parser V9.1 - Parse LLM 1 output avec support parall√©lisation\nconst llmResponse = $json;\nconst initData = $node['Init V8 Security & Analysis'].json;\nconst guardrailData = $node['üõ°Ô∏è Advanced Guardrails'].json;\n\nlet intentsData;\ntry {\n  const content = llmResponse.body?.choices?.[0]?.message?.content \n               || llmResponse.choices?.[0]?.message?.content || '{}';\n  intentsData = JSON.parse(content);\n} catch (e) {\n  // Fallback: single intent based on router\n  intentsData = {\n    reasoning: 'Fallback due to parsing error: ' + e.message,\n    intents: [{\n      id: 'intent-1',\n      description: initData.query,\n      type: 'FACTUAL',\n      suggested_rag: guardrailData.engine || 'STANDARD',\n      priority: 1,\n      depends_on: [],\n      can_parallelize_with: []\n    }],\n    execution_order: ['intent-1'],\n    has_parallel_intents: false,\n    complexity: 'SIMPLE'\n  };\n}\n\n// Validate intents\nconst validRags = ['STANDARD', 'GRAPH', 'QUANTITATIVE'];\nintentsData.intents = (intentsData.intents || []).map((intent, idx) => ({\n  ...intent,\n  id: intent.id || `intent-${idx + 1}`,\n  suggested_rag: validRags.includes(intent.suggested_rag) ? intent.suggested_rag : 'STANDARD',\n  priority: intent.priority || idx + 1,\n  depends_on: Array.isArray(intent.depends_on) ? intent.depends_on : [],\n  can_parallelize_with: Array.isArray(intent.can_parallelize_with) ? intent.can_parallelize_with : []\n}));\n\n// Determine if parallel execution is possible\nconst hasParallel = intentsData.has_parallel_intents || \n  intentsData.intents.some(i => i.can_parallelize_with?.length > 0);\n\n// Output format for LLM 2\nreturn {\n  trace_id: initData.trace_id,\n  original_query: initData.query,\n  user_context: initData.user_context,\n  \n  // Intent analysis\n  intents: intentsData.intents,\n  execution_order: intentsData.execution_order || intentsData.intents.map(i => i.id),\n  reasoning: intentsData.reasoning,\n  complexity: intentsData.complexity || 'MODERATE',\n  \n  // Parallelization info\n  has_parallel_intents: hasParallel,\n  \n  // Pass through\n  is_chat: $node['Input Merger V8'].json.is_chat,\n  is_webhook: $node['Input Merger V8'].json.is_webhook,\n  conversation_id: initData.conversation_id\n};",
      "metadata": {
        "rollback_for": "O01"
      }
    }
  ],
  "deployment_notes": "== DEPLOYMENT ORDER ==\n1. ISSUE-ORC-03 (P0): Apply cache key fix FIRST - requires Redis cache flush after deployment\n2. ISSUE-ORC-06 (P1): Update LLM 3 model - verify OpenRouter supports claude-sonnet-4-5-20250929\n3. ISSUE-ORC-09 (P2): Rename IF nodes - cosmetic, no functional impact\n4. ISSUE-ORC-13 (P2): Document-only - manual migration to n8n variables at operator discretion\n5. O01 (SOTA): Apply confidence routing - additive, non-breaking\n6. O03 (SOTA): Document-only - manual prompt enhancement, depends on O01\n\n== PRE-DEPLOYMENT CHECKLIST ==\n- [ ] Backup workflow JSON before patching\n- [ ] Verify node indices match (run test operations first)\n- [ ] Prepare Redis FLUSHDB or targeted key deletion for cache key format change\n- [ ] Confirm anthropic/claude-sonnet-4-5-20250929 is available on OpenRouter\n- [ ] After ISSUE-ORC-03: verify cache keys now have format 'tenant_id:32hexchars'\n- [ ] After ISSUE-ORC-09: verify workflow connections are intact in n8n editor\n\n== ROLLBACK PROCEDURE ==\nApply rollback_patches in REVERSE order if issues detected.\nCache key rollback (ISSUE-ORC-03) requires another Redis cache flush.\n",
  "test_cases": [
    {
      "id": "TC-ORC03-1",
      "description": "Verify cache key uses 32 chars with tenant prefix",
      "patch_ref": "ISSUE-ORC-03",
      "input": {
        "body": {
          "query": "What is the company policy?",
          "tenant_id": "acme-corp"
        }
      },
      "expected": {
        "query_hash_pattern": "^acme-corp:[a-f0-9]{32}$",
        "query_hash_length_min": 42
      }
    },
    {
      "id": "TC-ORC03-2",
      "description": "Verify default tenant prefix when tenant_id is missing",
      "patch_ref": "ISSUE-ORC-03",
      "input": {
        "body": {
          "query": "Hello world"
        }
      },
      "expected": {
        "query_hash_pattern": "^default:[a-f0-9]{32}$"
      }
    },
    {
      "id": "TC-ORC03-3",
      "description": "Verify different tenants produce different cache keys for same query",
      "patch_ref": "ISSUE-ORC-03",
      "input_a": {
        "body": {
          "query": "test",
          "tenant_id": "tenant-A"
        }
      },
      "input_b": {
        "body": {
          "query": "test",
          "tenant_id": "tenant-B"
        }
      },
      "expected": {
        "keys_differ": true,
        "reasoning": "Same query different tenant must produce different cache keys"
      }
    },
    {
      "id": "TC-ORC06-1",
      "description": "Verify LLM 3 uses updated model in API call",
      "patch_ref": "ISSUE-ORC-06",
      "validation": "Check that the jsonBody of node 51 contains 'claude-sonnet-4-5-20250929' and does NOT contain 'claude-3-5-sonnet-20241022'"
    },
    {
      "id": "TC-ORC09-1",
      "description": "Verify IF nodes have descriptive names and connections are intact",
      "patch_ref": "ISSUE-ORC-09",
      "validation": "In n8n editor: node 63 shows 'IF: All Execution Complete?', node 64 shows 'IF: Should Continue Loop?'. Execution flow: Engine -> IF:AllExec -> (true)ResponseBuilder / (false)DynamicSwitch. TaskUpdater -> IF:ShouldLoop -> (true)ApplySkips+InsertTasks / (false)stop."
    },
    {
      "id": "TC-O01-1",
      "description": "Verify confidence scoring produces valid scores",
      "patch_ref": "O01",
      "input": {
        "llm_response": {
          "choices": [
            {
              "message": {
                "content": "{\"reasoning\":\"Simple factual query about company policy\",\"intents\":[{\"id\":\"intent-1\",\"description\":\"Find company policy details\",\"type\":\"FACTUAL\",\"suggested_rag\":\"STANDARD\",\"priority\":1,\"depends_on\":[],\"can_parallelize_with\":[]}],\"execution_order\":[\"intent-1\"],\"has_parallel_intents\":false,\"complexity\":\"SIMPLE\"}"
              }
            }
          ]
        }
      },
      "expected": {
        "routing_confidence_range": [
          0.5,
          1.0
        ],
        "parse_confidence": 1.0,
        "intents_have_routing_confidence": true
      }
    },
    {
      "id": "TC-O01-2",
      "description": "Verify parse failure produces low confidence",
      "patch_ref": "O01",
      "input": {
        "llm_response": {
          "choices": [
            {
              "message": {
                "content": "invalid json!!!"
              }
            }
          ]
        }
      },
      "expected": {
        "parse_confidence": 0.2,
        "fallback_intent_created": true
      }
    }
  ]
}
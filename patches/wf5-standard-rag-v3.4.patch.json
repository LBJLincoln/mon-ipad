{
  "workflow_file": "TEST - SOTA 2026 - WF5 Standard RAG V3.4 - CORRECTED.json",
  "workflow_name": "TEST - SOTA 2026 - WF5 Standard RAG V3.4 - CORRECTED",
  "workflow_id": "qtBs2Wbi_raU2o_dqfdDC",
  "generated_at": "2026-02-06T00:03:35.861Z",
  "generated_by": "patch-writer-agent",
  "patch_version": "1.0.0",
  "summary": {
    "total_patches": 7,
    "issues_addressed": [
      "ISSUE-SR-01 (P0): BM25 without tenant_id filter - cross-tenant data leakage",
      "ISSUE-SR-02 (P0): ACL filter logic inverted - security bypass by default",
      "ISSUE-SR-04 (P1): Cohere Reranker receives placeholder - documented architectural fix needed",
      "ISSUE-SR-09 (P2): Confidence default 0.5 when no sources - misleading confidence",
      "ISSUE-SR-10 (P2): Excerpt truncation mid-word - poor UX"
    ],
    "sota_upgrades": [
      "R01: Cohere reranker model upgrade to rerank-v3.5",
      "R03: RRF min-max score normalization before fusion"
    ],
    "nodes_modified": [
      {
        "index": 2,
        "name": "Init & ACL Pre-Filter V3.4",
        "issues": [
          "ISSUE-SR-02"
        ]
      },
      {
        "index": 8,
        "name": "BM25 Search Postgres",
        "issues": [
          "ISSUE-SR-01"
        ]
      },
      {
        "index": 10,
        "name": "RRF Merge & Rank V3.4",
        "issues": [
          "R03"
        ]
      },
      {
        "index": 11,
        "name": "Cohere Reranker",
        "issues": [
          "R01"
        ]
      },
      {
        "index": 14,
        "name": "Response Formatter",
        "issues": [
          "ISSUE-SR-09",
          "ISSUE-SR-10"
        ]
      },
      {
        "index": 18,
        "name": "Sticky Note (Configuration)",
        "issues": [
          "ISSUE-SR-04",
          "R01"
        ]
      }
    ],
    "manual_actions_required": [
      "ISSUE-SR-04: Add IF node before Cohere Reranker to skip API call when skip_reranker=true"
    ]
  },
  "patches": [
    {
      "op": "replace",
      "path": "/nodes/8/parameters/query",
      "value": "SELECT id, content, source, \n       ts_rank(to_tsvector('french', content), plainto_tsquery('french', $1)) as bm25_score\nFROM documents \nWHERE is_obsolete = false \n  AND tenant_id = $2\n  AND to_tsvector('french', content) @@ plainto_tsquery('french', $1)\nORDER BY bm25_score DESC LIMIT 20",
      "metadata": {
        "issue_ref": "ISSUE-SR-01",
        "severity": "P0",
        "reason": "Add tenant_id filter to BM25 SQL query to prevent cross-tenant data leakage",
        "node_name": "BM25 Search Postgres",
        "node_index": 8,
        "before": "SELECT id, content, source, \n       ts_rank(to_tsvector('french', content), plainto_tsquery('french', $1)) as bm25_score\nFROM documents \nWHERE is_obsolete = false \n  AND to_tsvector('french', content) @@ plainto_tsquery('french', $1)\nORDER BY bm25_score DESC LIMIT 20"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/8/parameters/options/queryReplacement",
      "value": "=={{ $node['Init & ACL Pre-Filter V3.4'].json.query }},{{ $node['Init & ACL Pre-Filter V3.4'].json.user_context.tenant_id }}",
      "metadata": {
        "issue_ref": "ISSUE-SR-01",
        "severity": "P0",
        "reason": "Pass tenant_id as $2 parameter to bind in the SQL tenant filter",
        "node_name": "BM25 Search Postgres",
        "node_index": 8,
        "before": "=={{ $node['Init & ACL Pre-Filter V3.4'].json.query }}"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/2/parameters/jsCode",
      "value": "// Init & ACL Pre-Filter V3.4 - With Adaptive TopK\nconst rawInput = $input.first().json;\nconst input = rawInput.body || rawInput;\n\n// Parse query robustement\nlet queryStr = '';\nif (typeof input.query === 'string') {\n  queryStr = input.query;\n} else if (input.query && typeof input.query === 'object') {\n  queryStr = JSON.stringify(input.query);\n} else {\n  queryStr = String(input.query || '');\n}\n\nconst userContext = input.user_context || {};\nconst tenantId = userContext.tenant_id || input.tenant_id || 'default';\nconst userGroups = Array.isArray(userContext.groups) ? userContext.groups : ['admin', 'guest'];\n\n// V3.4: Analyse de complexitÃ© pour adaptive top_k\nconst COMPLEXITY_INDICATORS = {\n  simple: /^(qu'est-ce que|dÃ©finition|c'est quoi)/i,\n  moderate: /(comment|pourquoi|expliquer)/i,\n  complex: /(comparer|analyser|impact|relation|entre.*et)/i,\n  multi_hop: /(quel.*puis|d'abord.*ensuite|en tenant compte)/i\n};\n\nlet complexity = 'moderate';\nlet adaptiveTopK = 15;\n\nif (COMPLEXITY_INDICATORS.simple.test(queryStr)) {\n  complexity = 'simple';\n  adaptiveTopK = 8;\n} else if (COMPLEXITY_INDICATORS.multi_hop.test(queryStr)) {\n  complexity = 'complex';\n  adaptiveTopK = 25;\n} else if (COMPLEXITY_INDICATORS.complex.test(queryStr)) {\n  complexity = 'complex';\n  adaptiveTopK = 20;\n}\n\n// V3.4: Detect if query needs decomposition\nconst needsDecomposition = queryStr.length > 100 || \n                          queryStr.includes(' et ') ||\n                          queryStr.includes(' ainsi que ') ||\n                          COMPLEXITY_INDICATORS.complex.test(queryStr);\n\n// ACL filter (dÃ©sactivÃ© par dÃ©faut pour compatibilitÃ©)\nconst disableAcl = (input.disable_acl === true);\nconst aclFilter = disableAcl ? {} : {\n  \"$or\": [\n    { \"tenant_id\": tenantId, \"allowed_groups\": { \"$in\": userGroups } },\n    { \"tenant_id\": { \"$exists\": false } }\n  ]\n};\n\nreturn [{\n  json: {\n    trace_id: input.trace_id || 'tr-' + Date.now(),\n    query: queryStr.trim(),\n    acl_filter: aclFilter,\n    acl_disabled: disableAcl,\n    user_context: { tenant_id: tenantId, groups: userGroups },\n    \n    // V3.4 Enhancements\n    complexity: complexity,\n    topK: Math.min(input.topK || adaptiveTopK, 50),\n    adaptive_topK: adaptiveTopK,\n    needs_decomposition: needsDecomposition\n  }\n}];",
      "metadata": {
        "issue_ref": "ISSUE-SR-02",
        "severity": "P0",
        "reason": "Fix inverted ACL logic: ACL was disabled by default (disable_acl !== false evaluates to true for undefined). Now ACL is enabled by default and only disabled when disable_acl is explicitly set to true",
        "node_name": "Init & ACL Pre-Filter V3.4",
        "node_index": 2,
        "before_snippet": "const disableAcl = input.disable_acl !== false;",
        "after_snippet": "const disableAcl = (input.disable_acl === true);"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/18/parameters/content",
      "value": "# ðŸ”§ VARIABLES D'ENVIRONNEMENT REQUISES (SOTA 2026)\n\n## LLM APIs\n- `OPENROUTER_BASE_URL` - https://openrouter.ai/api/v1/chat/completions\n- `LLM_HYDE_MODEL` - google/gemini-2.0-flash-exp\n- `LLM_FAST_MODEL` - google/gemini-2.0-flash-exp\n\n## Embedding\n- `EMBEDDING_API_URL` - URL embedding API\n- `EMBEDDING_MODEL` - text-embedding-3-small\n\n## Reranking\n- `RERANKER_API_URL` - https://api.cohere.ai/v1/rerank\n- `RERANKER_MODEL` - rerank-v3.5 (upgraded from rerank-multilingual-v3.0)\n\n## CORRECTIONS V3.4.1:\n- Fixed HyDE Generator JSON body (removed orphan JS code)\n- Fixed Embedding model string (removed extra quotes)\n- Fixed Query Decomposer model reference\n\n## ISSUE-SR-04 (P1) - PENDING ARCHITECTURE CHANGE:\n- An IF node must be added BEFORE the Cohere Reranker node\n- Condition: skip_reranker === true â†’ bypass Cohere entirely\n- Currently when skip_reranker=true, a placeholder document is sent to Cohere\n- This wastes API credits and may produce misleading rerank scores\n- Route: RRF â†’ [new IF: Has Results?] â†’ true: Cohere â†’ Rerank Merger\n-                                      â†’ false: Rerank Merger (directly)\n- STATUS: Requires manual structural change (add node + rewire connections)\n",
      "metadata": {
        "issue_ref": "ISSUE-SR-04",
        "severity": "P1",
        "reason": "Document needed architectural change: add IF node before Cohere Reranker to skip API call when no results. This cannot be fully resolved via JSON Patch alone as it requires a new node and connection rewiring",
        "node_name": "Sticky Note (Configuration SOTA 2026)",
        "node_index": 18,
        "action_required": "manual",
        "manual_steps": [
          "Add a new IF node between 'RRF Merge & Rank V3.4' and 'Cohere Reranker'",
          "IF condition: {{ $json.skip_reranker }} equals true",
          "True output â†’ connect directly to 'Rerank Merger'",
          "False output â†’ connect to 'Cohere Reranker'",
          "Remove direct connection from 'RRF Merge & Rank V3.4' to 'Cohere Reranker'"
        ],
        "also_includes": "R01: Updated RERANKER_MODEL default reference in documentation"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/14/parameters/jsCode",
      "value": "// Response Formatter V3.4 - PATCHED (ISSUE-SR-09, ISSUE-SR-10)\nconst initData = $node['Init & ACL Pre-Filter V3.4'].json;\n\nif ($json.fallback_response) {\n  return [{ json: $json.fallback_response }];\n}\n\nif ($json.skip_llm === true) {\n  return [{ json: { response: \"Aucun document pertinent trouve.\", sources: [], metadata: $json.metadata || {}, trace_id: initData.trace_id, confidence: 0, engine: 'STANDARD' } }];\n}\n\nconst llmResponse = $json.choices?.[0]?.message?.content || 'Aucune reponse generee.';\nlet sources = [];\ntry { sources = $node['Rerank Merger'].json.results || []; } catch(e) {}\n\n// ISSUE-SR-10: Truncate excerpt at last word boundary before 200 chars\nfunction smartTruncate(text, maxLen) {\n  if (!text || text.length <= maxLen) return text || '';\n  const cut = text.substring(0, maxLen);\n  const lastSpace = cut.lastIndexOf(' ');\n  return (lastSpace > maxLen * 0.75 ? cut.substring(0, lastSpace) : cut) + '...';\n}\n\nreturn [{\n  json: {\n    response: llmResponse,\n    sources: sources.slice(0, 5).map(s => ({\n      source: s.source,\n      score: s.combined_score || s.rrf_score,\n      excerpt: smartTruncate(s.content, 200)\n    })),\n    metadata: $node['Rerank Merger'].json.metadata || {},\n    trace_id: initData.trace_id,\n    confidence: sources.length > 0 ? (sources[0]?.combined_score || sources[0]?.rrf_score || 0) : 0,\n    engine: 'STANDARD'\n  }\n}];",
      "metadata": {
        "issue_ref": "ISSUE-SR-09, ISSUE-SR-10",
        "severity": "P2",
        "reason": "ISSUE-SR-09: Change confidence default from 0.5 to 0 when no sources are found (misleading confidence). ISSUE-SR-10: Truncate excerpts at last word boundary before 200 chars instead of hard-cutting mid-word",
        "node_name": "Response Formatter",
        "node_index": 14,
        "changes": [
          {
            "issue": "ISSUE-SR-09",
            "before": "confidence: sources[0]?.combined_score || sources[0]?.rrf_score || 0.5",
            "after": "confidence: sources.length > 0 ? (sources[0]?.combined_score || sources[0]?.rrf_score || 0) : 0"
          },
          {
            "issue": "ISSUE-SR-10",
            "before": "excerpt: (s.content || '').substring(0, 200)",
            "after": "excerpt: smartTruncate(s.content, 200) â€” truncates at last space before 200 chars"
          }
        ]
      }
    },
    {
      "op": "replace",
      "path": "/nodes/11/parameters/jsonBody",
      "value": "={\n  \"model\": \"{{ $vars.RERANKER_MODEL || 'rerank-v3.5' }}\",\n  \"query\": {{ JSON.stringify($node['Init & ACL Pre-Filter V3.4'].json.query || '') }},\n  \"documents\": {{ $json.skip_reranker ? '[\"placeholder\"]' : JSON.stringify(($json.results || []).map(r => r.content || '').filter(c => c.length > 0).slice(0, 25)) }},\n  \"top_n\": 10\n}",
      "metadata": {
        "issue_ref": "R01",
        "severity": "SOTA-2026",
        "reason": "Upgrade Cohere reranker model from rerank-multilingual-v3.0 to rerank-v3.5 for improved relevance scoring and multilingual support per SOTA 2026 specifications",
        "node_name": "Cohere Reranker",
        "node_index": 11,
        "before_snippet": "rerank-multilingual-v3.0",
        "after_snippet": "rerank-v3.5"
      }
    },
    {
      "op": "replace",
      "path": "/nodes/10/parameters/jsCode",
      "value": "// ============================================\n// PATCH 07 - RRF Merge & Rank V3.4.2\n// FIX: Lecture robuste des 3 sources (HyDE, Original, BM25)\n// ============================================\n//\n// PROBLÃˆME RÃ‰SOLU:\n// Le code prÃ©cÃ©dent Ã©chouait silencieusement sur BM25\n// car le nÅ“ud Merge ne passait pas les donnÃ©es correctement.\n//\n// SOLUTION:\n// Lire directement depuis chaque nÅ“ud source au lieu\n// de dÃ©pendre du Merge node.\n//\n// INSTRUCTIONS:\n// 1. Ouvrir le nÅ“ud \"RRF Merge & Rank V3.4\" dans le workflow RAG Standard\n// 2. Remplacer tout le code par celui-ci\n// 3. Sauvegarder\n// ============================================\n\n// RRF Merge & Rank V3.4.2 - Direct source reading\nconst k = 60; // ParamÃ¨tre RRF standard\nconst BOOSTS = { hyde: 1.3, bm25: 1.2, pinecone: 1.0 };\nlet scores = {};\nlet warnings = [];\nlet sourcesAvailable = 0;\n\n// RÃ©cupÃ©rer les mÃ©tadonnÃ©es\nconst initData = $node['Init & ACL Pre-Filter V3.4'].json;\nconst traceId = initData.trace_id;\n\n// V3.4: Check if queries were decomposed\nlet isDecomposed = false;\ntry {\n  const queryData = $node['Query Merger V3.4']?.json;\n  isDecomposed = queryData?.is_decomposed || false;\n} catch (e) {\n  // Query Merger pas dans le flux\n}\nconst decompositionBoost = isDecomposed ? 1.1 : 1.0;\n\n// === HELPER FUNCTIONS ===\nfunction extractContent(metadata) {\n  return metadata?.text || metadata?.content || metadata?.chunk_text || metadata?.page_content || '';\n}\n\nfunction safeReadNode(nodeName) {\n  try {\n    return $node[nodeName]?.json;\n  } catch (e) {\n    console.log(`[${traceId}] Cannot read ${nodeName}: ${e.message}`);\n    return null;\n  }\n}\n\n// === SOURCE 1: HyDE Pinecone ===\nconsole.log(`[${traceId}] Reading HyDE results...`);\ntry {\n  const hydeData = safeReadNode('HTTP Pinecone Query HyDE');\n  const hydeMatches = hydeData?.matches || [];\n  \n  if (hydeMatches.length > 0) {\n    sourcesAvailable++;\n    hydeMatches.forEach((item, index) => {\n      const id = item.id;\n      const rrfScore = (1 / (k + index + 1)) * BOOSTS.hyde * decompositionBoost;\n      \n      if (scores[id]) { \n        scores[id].score += rrfScore; \n        if (!scores[id].sources.includes('hyde')) {\n          scores[id].sources.push('hyde');\n        }\n      } else { \n        scores[id] = { \n          score: rrfScore, \n          data: item.metadata, \n          pineconeScore: item.score, \n          sources: ['hyde'] \n        }; \n      }\n    });\n    console.log(`[${traceId}] HyDE: ${hydeMatches.length} results added`);\n  } else { \n    warnings.push('HyDE: 0 results'); \n  }\n} catch(e) { \n  warnings.push('HyDE error: ' + e.message);\n  console.error(`[${traceId}] HyDE error:`, e.message);\n}\n\n// === SOURCE 2: Original Pinecone ===\nconsole.log(`[${traceId}] Reading Original Embedding results...`);\ntry {\n  const originalData = safeReadNode('HTTP Pinecone Query Original');\n  const originalMatches = originalData?.matches || [];\n  \n  if (originalMatches.length > 0) {\n    sourcesAvailable++;\n    originalMatches.forEach((item, index) => {\n      const id = item.id;\n      const rrfScore = (1 / (k + index + 1)) * BOOSTS.pinecone;\n      \n      if (scores[id]) { \n        scores[id].score += rrfScore; \n        if (!scores[id].sources.includes('original')) {\n          scores[id].sources.push('original'); \n        }\n      } else { \n        scores[id] = { \n          score: rrfScore, \n          data: item.metadata, \n          pineconeScore: item.score, \n          sources: ['original'] \n        }; \n      }\n    });\n    console.log(`[${traceId}] Original: ${originalMatches.length} results added`);\n  } else { \n    warnings.push('Original: 0 results'); \n  }\n} catch(e) { \n  warnings.push('Original error: ' + e.message);\n  console.error(`[${traceId}] Original error:`, e.message);\n}\n\n// === SOURCE 3: BM25 Postgres ===\nconsole.log(`[${traceId}] Reading BM25 results...`);\ntry {\n  const bm25Raw = safeReadNode('BM25 Search Postgres');\n  \n  // BM25 peut retourner diffÃ©rents formats:\n  // - Array de rÃ©sultats\n  // - Objet unique avec {id, content, bm25_score}\n  // - Null/undefined si erreur\n  \n  let bm25Data = [];\n  \n  if (Array.isArray(bm25Raw)) {\n    bm25Data = bm25Raw;\n  } else if (bm25Raw && typeof bm25Raw === 'object') {\n    if (bm25Raw.id) {\n      // Single result object\n      bm25Data = [bm25Raw];\n    } else if (bm25Raw.error) {\n      // Postgres error\n      throw new Error(bm25Raw.error.message || 'Postgres error');\n    }\n  }\n  \n  // Filtrer les rÃ©sultats valides\n  bm25Data = bm25Data.filter(item => item && item.id && item.content);\n  \n  if (bm25Data.length > 0) {\n    sourcesAvailable++;\n    bm25Data.forEach((item, index) => {\n      const id = 'bm25-' + String(item.id);\n      const rrfScore = (1 / (k + index + 1)) * BOOSTS.bm25;\n      \n      if (scores[id]) { \n        scores[id].score += rrfScore; \n        scores[id].sources.push('bm25'); \n      } else { \n        scores[id] = { \n          score: rrfScore, \n          data: { \n            content: item.content, \n            source: item.source || 'postgres', \n            text: item.content \n          }, \n          bm25Score: item.bm25_score, \n          sources: ['bm25'] \n        }; \n      }\n    });\n    console.log(`[${traceId}] BM25: ${bm25Data.length} results added`);\n  } else { \n    warnings.push('BM25: 0 results (may need tenant_id configuration)'); \n  }\n} catch(e) { \n  warnings.push('BM25 error: ' + e.message);\n  console.error(`[${traceId}] BM25 error:`, e.message);\n}\n\n// === RANKING FINAL ===\n// R03 SOTA 2026: Min-max normalization of RRF scores before final ranking\nconst allEntries = Object.entries(scores)\n  .map(([id, r]) => ({ id, ...r }));\n\nif (allEntries.length > 1) {\n  const rawScores = allEntries.map(e => e.score);\n  const minScore = Math.min(...rawScores);\n  const maxScore = Math.max(...rawScores);\n  const range = maxScore - minScore;\n  if (range > 0) {\n    allEntries.forEach(e => {\n      e.raw_rrf_score = e.score;\n      e.score = (e.score - minScore) / range;\n    });\n    console.log(`[${traceId}] RRF normalization applied: min=${minScore.toFixed(6)}, max=${maxScore.toFixed(6)}`);\n  }\n}\n\nconst ranked = allEntries.sort((a, b) => b.score - a.score);\n\nconst hasResults = ranked.length > 0;\n\nconsole.log(`[${traceId}] RRF complete: ${ranked.length} unique docs from ${sourcesAvailable} sources`);\nif (warnings.length > 0) {\n  console.log(`[${traceId}] Warnings: ${warnings.join(', ')}`);\n}\n\n// === OUTPUT ===\nreturn [{\n  json: {\n    results: ranked.slice(0, 15).map(r => ({\n      id: r.id,\n      content: extractContent(r.data),\n      source: r.data?.source || r.data?.dataset || 'unknown',\n      rrf_score: Math.round(r.score * 10000) / 10000,\n      raw_rrf_score: r.raw_rrf_score ? Math.round(r.raw_rrf_score * 10000) / 10000 : undefined,\n      pinecone_score: r.pineconeScore,\n      bm25_score: r.bm25Score,\n      sources_used: r.sources\n    })),\n    metadata: { \n      sources_available: sourcesAvailable,\n      total_unique_docs: ranked.length,\n      warnings: warnings,\n      is_decomposed: isDecomposed,\n      rrf_normalized: true,\n      version: '3.4.3',\n      trace_id: traceId\n    },\n    skip_reranker: !hasResults\n  }\n}];",
      "metadata": {
        "issue_ref": "R03",
        "severity": "SOTA-2026",
        "reason": "Add min-max normalization to RRF scores before final ranking. Raw scores are preserved in raw_rrf_score field. Normalized scores range [0,1] enabling fair comparison across different score distributions from HyDE, Original, and BM25 sources",
        "node_name": "RRF Merge & Rank V3.4",
        "node_index": 10,
        "changes": [
          "Added min-max normalization block after score accumulation",
          "Preserved raw_rrf_score in output for debugging/auditing",
          "Added rrf_normalized: true flag to metadata",
          "Updated version to 3.4.3"
        ]
      }
    }
  ],
  "rollback_patches": [
    {
      "op": "replace",
      "path": "/nodes/8/parameters/query",
      "value": "SELECT id, content, source, \n       ts_rank(to_tsvector('french', content), plainto_tsquery('french', $1)) as bm25_score\nFROM documents \nWHERE is_obsolete = false \n  AND to_tsvector('french', content) @@ plainto_tsquery('french', $1)\nORDER BY bm25_score DESC LIMIT 20"
    },
    {
      "op": "replace",
      "path": "/nodes/8/parameters/options/queryReplacement",
      "value": "=={{ $node['Init & ACL Pre-Filter V3.4'].json.query }}"
    },
    {
      "op": "replace",
      "path": "/nodes/2/parameters/jsCode",
      "value": "// Init & ACL Pre-Filter V3.4 - With Adaptive TopK\nconst rawInput = $input.first().json;\nconst input = rawInput.body || rawInput;\n\n// Parse query robustement\nlet queryStr = '';\nif (typeof input.query === 'string') {\n  queryStr = input.query;\n} else if (input.query && typeof input.query === 'object') {\n  queryStr = JSON.stringify(input.query);\n} else {\n  queryStr = String(input.query || '');\n}\n\nconst userContext = input.user_context || {};\nconst tenantId = userContext.tenant_id || input.tenant_id || 'default';\nconst userGroups = Array.isArray(userContext.groups) ? userContext.groups : ['admin', 'guest'];\n\n// V3.4: Analyse de complexitÃ© pour adaptive top_k\nconst COMPLEXITY_INDICATORS = {\n  simple: /^(qu'est-ce que|dÃ©finition|c'est quoi)/i,\n  moderate: /(comment|pourquoi|expliquer)/i,\n  complex: /(comparer|analyser|impact|relation|entre.*et)/i,\n  multi_hop: /(quel.*puis|d'abord.*ensuite|en tenant compte)/i\n};\n\nlet complexity = 'moderate';\nlet adaptiveTopK = 15;\n\nif (COMPLEXITY_INDICATORS.simple.test(queryStr)) {\n  complexity = 'simple';\n  adaptiveTopK = 8;\n} else if (COMPLEXITY_INDICATORS.multi_hop.test(queryStr)) {\n  complexity = 'complex';\n  adaptiveTopK = 25;\n} else if (COMPLEXITY_INDICATORS.complex.test(queryStr)) {\n  complexity = 'complex';\n  adaptiveTopK = 20;\n}\n\n// V3.4: Detect if query needs decomposition\nconst needsDecomposition = queryStr.length > 100 || \n                          queryStr.includes(' et ') ||\n                          queryStr.includes(' ainsi que ') ||\n                          COMPLEXITY_INDICATORS.complex.test(queryStr);\n\n// ACL filter (dÃ©sactivÃ© par dÃ©faut pour compatibilitÃ©)\nconst disableAcl = input.disable_acl !== false;\nconst aclFilter = disableAcl ? {} : {\n  \"$or\": [\n    { \"tenant_id\": tenantId, \"allowed_groups\": { \"$in\": userGroups } },\n    { \"tenant_id\": { \"$exists\": false } }\n  ]\n};\n\nreturn [{\n  json: {\n    trace_id: input.trace_id || 'tr-' + Date.now(),\n    query: queryStr.trim(),\n    acl_filter: aclFilter,\n    acl_disabled: disableAcl,\n    user_context: { tenant_id: tenantId, groups: userGroups },\n    \n    // V3.4 Enhancements\n    complexity: complexity,\n    topK: Math.min(input.topK || adaptiveTopK, 50),\n    adaptive_topK: adaptiveTopK,\n    needs_decomposition: needsDecomposition\n  }\n}];"
    },
    {
      "op": "replace",
      "path": "/nodes/18/parameters/content",
      "value": "# ðŸ”§ VARIABLES D'ENVIRONNEMENT REQUISES (SOTA 2026)\n\n## LLM APIs\n- `OPENROUTER_BASE_URL` - https://openrouter.ai/api/v1/chat/completions\n- `LLM_HYDE_MODEL` - google/gemini-2.0-flash-exp\n- `LLM_FAST_MODEL` - google/gemini-2.0-flash-exp\n\n## Embedding\n- `EMBEDDING_API_URL` - URL embedding API\n- `EMBEDDING_MODEL` - text-embedding-3-small\n\n## Reranking\n- `RERANKER_API_URL` - https://api.cohere.ai/v1/rerank\n- `RERANKER_MODEL` - rerank-multilingual-v3.0\n\n## CORRECTIONS V3.4.1:\n- Fixed HyDE Generator JSON body (removed orphan JS code)\n- Fixed Embedding model string (removed extra quotes)\n- Fixed Query Decomposer model reference\n"
    },
    {
      "op": "replace",
      "path": "/nodes/14/parameters/jsCode",
      "value": "// Response Formatter V3.3\nconst initData = $node['Init & ACL Pre-Filter V3.4'].json;\n\nif ($json.fallback_response) {\n  return [{ json: $json.fallback_response }];\n}\n\nif ($json.skip_llm === true) {\n  return [{ json: { response: \"Aucun document pertinent trouve.\", sources: [], metadata: $json.metadata || {}, trace_id: initData.trace_id, confidence: 0, engine: 'STANDARD' } }];\n}\n\nconst llmResponse = $json.choices?.[0]?.message?.content || 'Aucune reponse generee.';\nlet sources = [];\ntry { sources = $node['Rerank Merger'].json.results || []; } catch(e) {}\n\nreturn [{\n  json: {\n    response: llmResponse,\n    sources: sources.slice(0, 5).map(s => ({ source: s.source, score: s.combined_score || s.rrf_score, excerpt: (s.content || '').substring(0, 200) })),\n    metadata: $node['Rerank Merger'].json.metadata || {},\n    trace_id: initData.trace_id,\n    confidence: sources[0]?.combined_score || sources[0]?.rrf_score || 0.5,\n    engine: 'STANDARD'\n  }\n}];"
    },
    {
      "op": "replace",
      "path": "/nodes/11/parameters/jsonBody",
      "value": "={\n  \"model\": \"{{ $vars.RERANKER_MODEL || 'rerank-multilingual-v3.0' }}\",\n  \"query\": {{ JSON.stringify($node['Init & ACL Pre-Filter V3.4'].json.query || '') }},\n  \"documents\": {{ $json.skip_reranker ? '[\"placeholder\"]' : JSON.stringify(($json.results || []).map(r => r.content || '').filter(c => c.length > 0).slice(0, 25)) }},\n  \"top_n\": 10\n}"
    },
    {
      "op": "replace",
      "path": "/nodes/10/parameters/jsCode",
      "value": "// ============================================\n// PATCH 07 - RRF Merge & Rank V3.4.2\n// FIX: Lecture robuste des 3 sources (HyDE, Original, BM25)\n// ============================================\n//\n// PROBLÃˆME RÃ‰SOLU:\n// Le code prÃ©cÃ©dent Ã©chouait silencieusement sur BM25\n// car le nÅ“ud Merge ne passait pas les donnÃ©es correctement.\n//\n// SOLUTION:\n// Lire directement depuis chaque nÅ“ud source au lieu\n// de dÃ©pendre du Merge node.\n//\n// INSTRUCTIONS:\n// 1. Ouvrir le nÅ“ud \"RRF Merge & Rank V3.4\" dans le workflow RAG Standard\n// 2. Remplacer tout le code par celui-ci\n// 3. Sauvegarder\n// ============================================\n\n// RRF Merge & Rank V3.4.2 - Direct source reading\nconst k = 60; // ParamÃ¨tre RRF standard\nconst BOOSTS = { hyde: 1.3, bm25: 1.2, pinecone: 1.0 };\nlet scores = {};\nlet warnings = [];\nlet sourcesAvailable = 0;\n\n// RÃ©cupÃ©rer les mÃ©tadonnÃ©es\nconst initData = $node['Init & ACL Pre-Filter V3.4'].json;\nconst traceId = initData.trace_id;\n\n// V3.4: Check if queries were decomposed\nlet isDecomposed = false;\ntry {\n  const queryData = $node['Query Merger V3.4']?.json;\n  isDecomposed = queryData?.is_decomposed || false;\n} catch (e) {\n  // Query Merger pas dans le flux\n}\nconst decompositionBoost = isDecomposed ? 1.1 : 1.0;\n\n// === HELPER FUNCTIONS ===\nfunction extractContent(metadata) {\n  return metadata?.text || metadata?.content || metadata?.chunk_text || metadata?.page_content || '';\n}\n\nfunction safeReadNode(nodeName) {\n  try {\n    return $node[nodeName]?.json;\n  } catch (e) {\n    console.log(`[${traceId}] Cannot read ${nodeName}: ${e.message}`);\n    return null;\n  }\n}\n\n// === SOURCE 1: HyDE Pinecone ===\nconsole.log(`[${traceId}] Reading HyDE results...`);\ntry {\n  const hydeData = safeReadNode('HTTP Pinecone Query HyDE');\n  const hydeMatches = hydeData?.matches || [];\n  \n  if (hydeMatches.length > 0) {\n    sourcesAvailable++;\n    hydeMatches.forEach((item, index) => {\n      const id = item.id;\n      const rrfScore = (1 / (k + index + 1)) * BOOSTS.hyde * decompositionBoost;\n      \n      if (scores[id]) { \n        scores[id].score += rrfScore; \n        if (!scores[id].sources.includes('hyde')) {\n          scores[id].sources.push('hyde');\n        }\n      } else { \n        scores[id] = { \n          score: rrfScore, \n          data: item.metadata, \n          pineconeScore: item.score, \n          sources: ['hyde'] \n        }; \n      }\n    });\n    console.log(`[${traceId}] HyDE: ${hydeMatches.length} results added`);\n  } else { \n    warnings.push('HyDE: 0 results'); \n  }\n} catch(e) { \n  warnings.push('HyDE error: ' + e.message);\n  console.error(`[${traceId}] HyDE error:`, e.message);\n}\n\n// === SOURCE 2: Original Pinecone ===\nconsole.log(`[${traceId}] Reading Original Embedding results...`);\ntry {\n  const originalData = safeReadNode('HTTP Pinecone Query Original');\n  const originalMatches = originalData?.matches || [];\n  \n  if (originalMatches.length > 0) {\n    sourcesAvailable++;\n    originalMatches.forEach((item, index) => {\n      const id = item.id;\n      const rrfScore = (1 / (k + index + 1)) * BOOSTS.pinecone;\n      \n      if (scores[id]) { \n        scores[id].score += rrfScore; \n        if (!scores[id].sources.includes('original')) {\n          scores[id].sources.push('original'); \n        }\n      } else { \n        scores[id] = { \n          score: rrfScore, \n          data: item.metadata, \n          pineconeScore: item.score, \n          sources: ['original'] \n        }; \n      }\n    });\n    console.log(`[${traceId}] Original: ${originalMatches.length} results added`);\n  } else { \n    warnings.push('Original: 0 results'); \n  }\n} catch(e) { \n  warnings.push('Original error: ' + e.message);\n  console.error(`[${traceId}] Original error:`, e.message);\n}\n\n// === SOURCE 3: BM25 Postgres ===\nconsole.log(`[${traceId}] Reading BM25 results...`);\ntry {\n  const bm25Raw = safeReadNode('BM25 Search Postgres');\n  \n  // BM25 peut retourner diffÃ©rents formats:\n  // - Array de rÃ©sultats\n  // - Objet unique avec {id, content, bm25_score}\n  // - Null/undefined si erreur\n  \n  let bm25Data = [];\n  \n  if (Array.isArray(bm25Raw)) {\n    bm25Data = bm25Raw;\n  } else if (bm25Raw && typeof bm25Raw === 'object') {\n    if (bm25Raw.id) {\n      // Single result object\n      bm25Data = [bm25Raw];\n    } else if (bm25Raw.error) {\n      // Postgres error\n      throw new Error(bm25Raw.error.message || 'Postgres error');\n    }\n  }\n  \n  // Filtrer les rÃ©sultats valides\n  bm25Data = bm25Data.filter(item => item && item.id && item.content);\n  \n  if (bm25Data.length > 0) {\n    sourcesAvailable++;\n    bm25Data.forEach((item, index) => {\n      const id = 'bm25-' + String(item.id);\n      const rrfScore = (1 / (k + index + 1)) * BOOSTS.bm25;\n      \n      if (scores[id]) { \n        scores[id].score += rrfScore; \n        scores[id].sources.push('bm25'); \n      } else { \n        scores[id] = { \n          score: rrfScore, \n          data: { \n            content: item.content, \n            source: item.source || 'postgres', \n            text: item.content \n          }, \n          bm25Score: item.bm25_score, \n          sources: ['bm25'] \n        }; \n      }\n    });\n    console.log(`[${traceId}] BM25: ${bm25Data.length} results added`);\n  } else { \n    warnings.push('BM25: 0 results (may need tenant_id configuration)'); \n  }\n} catch(e) { \n  warnings.push('BM25 error: ' + e.message);\n  console.error(`[${traceId}] BM25 error:`, e.message);\n}\n\n// === RANKING FINAL ===\nconst ranked = Object.entries(scores)\n  .map(([id, r]) => ({ id, ...r }))\n  .sort((a, b) => b.score - a.score);\n\nconst hasResults = ranked.length > 0;\n\nconsole.log(`[${traceId}] RRF complete: ${ranked.length} unique docs from ${sourcesAvailable} sources`);\nif (warnings.length > 0) {\n  console.log(`[${traceId}] Warnings: ${warnings.join(', ')}`);\n}\n\n// === OUTPUT ===\nreturn [{\n  json: {\n    results: ranked.slice(0, 15).map(r => ({\n      id: r.id,\n      content: extractContent(r.data),\n      source: r.data?.source || r.data?.dataset || 'unknown',\n      rrf_score: Math.round(r.score * 10000) / 10000,\n      pinecone_score: r.pineconeScore,\n      bm25_score: r.bm25Score,\n      sources_used: r.sources\n    })),\n    metadata: { \n      sources_available: sourcesAvailable,\n      total_unique_docs: ranked.length,\n      warnings: warnings,\n      is_decomposed: isDecomposed,\n      version: '3.4.2',\n      trace_id: traceId\n    },\n    skip_reranker: !hasResults\n  }\n}];"
    }
  ],
  "deployment_notes": [
    "P0 patches (ISSUE-SR-01, ISSUE-SR-02) address security vulnerabilities and MUST be deployed immediately",
    "ISSUE-SR-01: After deployment, verify BM25 queries filter by tenant_id by checking Supabase query logs",
    "ISSUE-SR-02: After deployment, verify ACL is enabled by default â€” test with a request without disable_acl field",
    "ISSUE-SR-04: Requires manual IF node addition in n8n editor â€” cannot be fully automated via JSON Patch",
    "R01: Ensure Cohere API key has access to rerank-v3.5 model before deploying",
    "R03: RRF normalization changes score distribution â€” reranker weights may need recalibration"
  ],
  "test_cases": [
    {
      "description": "ISSUE-SR-01: BM25 filters by tenant_id",
      "input": {
        "query": "test query",
        "user_context": {
          "tenant_id": "tenant-abc",
          "groups": [
            "admin"
          ]
        }
      },
      "expected": {
        "bm25_results_filtered": true,
        "all_results_belong_to": "tenant-abc"
      }
    },
    {
      "description": "ISSUE-SR-02: ACL enabled by default (no disable_acl field)",
      "input": {
        "query": "test query",
        "user_context": {
          "tenant_id": "t1",
          "groups": [
            "users"
          ]
        }
      },
      "expected": {
        "acl_disabled": false,
        "acl_filter": {
          "$or": "non-empty"
        }
      }
    },
    {
      "description": "ISSUE-SR-02: ACL disabled only when explicitly requested",
      "input": {
        "query": "test query",
        "disable_acl": true,
        "user_context": {
          "tenant_id": "t1",
          "groups": [
            "users"
          ]
        }
      },
      "expected": {
        "acl_disabled": true,
        "acl_filter": {}
      }
    },
    {
      "description": "ISSUE-SR-09: Confidence is 0 when no sources found",
      "input": {
        "query": "unknown topic with no documents"
      },
      "expected": {
        "confidence": 0,
        "sources": []
      }
    },
    {
      "description": "ISSUE-SR-10: Excerpt truncated at word boundary",
      "input": {
        "content_with_250_chars": "a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]"
      },
      "expected": {
        "excerpt_length_lte": 203,
        "excerpt_ends_with": "...",
        "no_mid_word_cut": true
      }
    },
    {
      "description": "R01: Cohere uses rerank-v3.5 model",
      "input": {
        "query": "any query",
        "results": [
          {
            "content": "doc1"
          }
        ]
      },
      "expected": {
        "cohere_model": "rerank-v3.5"
      }
    },
    {
      "description": "R03: RRF scores are normalized between 0 and 1",
      "input": {
        "multiple_sources_with_results": true
      },
      "expected": {
        "rrf_scores_min": 0,
        "rrf_scores_max": 1,
        "rrf_normalized": true
      }
    }
  ]
}
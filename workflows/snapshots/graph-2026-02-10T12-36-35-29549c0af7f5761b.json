{
  "updatedAt": "2026-02-10T12:08:29.664Z",
  "createdAt": "2026-01-30T16:54:29.973Z",
  "id": "95x2BBAbJlLWZtWEJn6rb",
  "name": "TEST - SOTA 2026 - WF2 Graph RAG V3.3 - CORRECTED",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "jsCode": "// ============================================\n// PATCH #1: INIT & ACL - ORCHESTRATOR SUPPORT\n// ============================================\n// Pour: WF4 Quantitative & WF2 Graph\n// Bug: Workflows Ã©chouent quand appelÃ©s par orchestrateur\n// Fix: Support multi-format d'entrÃ©e\n\n// Init & ACL for RAG - HARDENED V2.2 (ORCHESTRATOR FIX)\nconst rawInput = $input.first().json;\nconst input = rawInput.body || rawInput;\n\n// === EXTRACTION ROBUSTE DE LA QUERY ===\n// Supporte: webhook, chat trigger, sub-workflow, ET orchestrator\nlet queryStr = '';\n\n// PrioritÃ© 1: Direct query field (webhook/chat)\nif (typeof input.query === 'string') {\n  queryStr = input.query;\n}\n// PrioritÃ© 2: Chat input\nelse if (input.chatInput) {\n  queryStr = input.chatInput;\n}\n// PrioritÃ© 3: Orchestrator format - task_query\nelse if (input.task_query) {\n  queryStr = input.task_query;\n}\n// PrioritÃ© 4: Orchestrator format - current_task.query\nelse if (input.current_task && typeof input.current_task.query === 'string') {\n  queryStr = input.current_task.query;\n}\n// PrioritÃ© 5: Query as object (stringify)\nelse if (input.query && typeof input.query === 'object') {\n  queryStr = JSON.stringify(input.query);\n}\n\n// Accept both query and question fields\n// Accept both query and question fields\n// Accept both query and question fields\nconst query = queryStr.trim();\n\n// === VALIDATION ===\nif (!query || query.length < 2) {\n  throw new Error('VALIDATION_ERROR: query is required and must be at least 2 characters');\n}\n\n// === EXTRACTION DU USER CONTEXT ===\n// Parse user_context (peut Ãªtre string JSON ou objet)\nlet userContext = {};\n\nif (typeof input.user_context === 'string') {\n  try {\n    userContext = JSON.parse(input.user_context);\n  } catch (e) {\n    userContext = {};\n  }\n} else if (input.user_context && typeof input.user_context === 'object') {\n  userContext = input.user_context;\n}\n\n// === EXTRACTION DU TRACE_ID ===\n// Support multiple sources\nconst traceId = input.trace_id || \n                input.current_task?.trace_id || \n                `tr-rag-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;\n\n// === OUTPUT ===\nreturn [{\n  json: {\n    trace_id: traceId,\n    query: query.substring(0, 2000),\n    user_context: {\n      tenant_id: userContext.tenant_id || input.tenant_id || 'default',\n      groups: Array.isArray(userContext.groups) ? userContext.groups : ['guest']\n    },\n    timestamp: new Date().toISOString(),\n    source: rawInput.body ? 'webhook' : \n            (rawInput.chatInput ? 'chat' : \n            (input.task_query ? 'orchestrator' : 'subworkflow')),\n    \n    // Metadata pour debugging\n    _debug: {\n      original_input_keys: Object.keys(input),\n      query_source: input.task_query ? 'task_query' : \n                    (input.current_task ? 'current_task.query' : \n                    (input.chatInput ? 'chatInput' : 'query'))\n    }\n  }\n}];\n"
      },
      "id": "0435899c-c6f9-4688-8bec-f0052ec0ecf2",
      "name": "OTEL Init",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        6400
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.OPENROUTER_BASE_URL || 'https://openrouter.ai/api/v1/chat/completions' }}",
        "authentication": "none",
        "nodeCredentialType": "openRouterApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"{{ $vars.LLM_HYDE_MODEL || 'google/gemma-3-27b-it:free' }}\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Generate a hypothetical document that would perfectly answer the question. This document will be used for semantic search. Format: dense, factual text, 200-300 words. Also extract key entities as JSON: {\\\"hyde_document\\\": string, \\\"entities\\\": [{\\\"name\\\": string, \\\"type\\\": string}]}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.query }}\"\n    }\n  ],\n  \"temperature\": 0.7,\n  \"max_tokens\": 800\n}",
        "options": {
          "timeout": 25000,
          "retry": {
            "maxTries": 3,
            "waitBetweenTries": 2000
          }
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $vars.OPENROUTER_API_KEY }}"
            }
          ]
        }
      },
      "id": "89b5c399-d785-424c-81d8-312bc84650c1",
      "name": "WF3: HyDE & Entity Extraction",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        288,
        6400
      ],
      "credentials": {},
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Neo4j Query Builder (Deep Traversal V2) - with NLP entity extraction fallback\nconst initData = $node['OTEL Init'].json;\nconst rawContent = $json.choices?.[0]?.message?.content || '';\n\nlet hydeDocument = '';\nlet extractedEntities = [];\n\n// Strategy 1: Try JSON parse\ntry {\n  const parsed = JSON.parse(rawContent);\n  hydeDocument = parsed.hyde_document || '';\n  extractedEntities = (parsed.entities || [])\n    .filter(e => e && typeof e.name === 'string')\n    .map(e => e.name);\n} catch (e) {\n  // Strategy 2: Try embedded JSON\n  const jsonMatch = rawContent.match(/\\{[\\s\\S]*\"entities\"[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    try {\n      const embedded = JSON.parse(jsonMatch[0]);\n      hydeDocument = embedded.hyde_document || '';\n      extractedEntities = (embedded.entities || [])\n        .filter(e => e && typeof e.name === 'string')\n        .map(e => e.name);\n    } catch (e2) {}\n  }\n}\n\n// Strategy 3: NLP-based entity extraction from plain text\nif (extractedEntities.length === 0) {\n  hydeDocument = rawContent;\n  const fullText = rawContent + ' ' + initData.query;\n  \n  const stopWords = new Set([\n    'The', 'What', 'Who', 'Where', 'When', 'How', 'Which', 'Did', 'Does',\n    'Was', 'Were', 'Are', 'Is', 'For', 'This', 'That', 'These', 'Those',\n    'Her', 'His', 'Its', 'She', 'They', 'Not', 'Also', 'Both', 'But',\n    'And', 'Has', 'Had', 'Have', 'Can', 'May', 'Will', 'Our', 'All',\n    'Such', 'Two', 'One', 'First', 'He', 'In', 'As', 'An',\n    'Modern', 'Today', 'Years', 'Only', 'Particularly', 'Remains',\n    'Significant', 'Important', 'Format', 'Throughout', 'Despite',\n    'However', 'Although', 'Furthermore', 'Moreover', 'Additionally',\n    'Meanwhile', 'Nevertheless', 'Consequently', 'Subsequently',\n    'Ultimately', 'Indeed', 'Several', 'Various', 'Numerous',\n    'During', 'Between', 'Within', 'Beyond', 'After', 'Before'\n  ]);\n  \n  const properNouns = fullText.match(/[A-Z\\u00C0-\\u00DC][a-z\\u00E0-\\u00FF]+(?:\\s+[A-Z\\u00C0-\\u00DC][a-z\\u00E0-\\u00FF]+)*/g) || [];\n  \n  const seen = new Set();\n  for (const noun of properNouns) {\n    const clean = noun.trim();\n    if (clean.length > 2 && !stopWords.has(clean) && !seen.has(clean.toLowerCase())) {\n      seen.add(clean.toLowerCase());\n      extractedEntities.push(clean);\n    }\n  }\n  \n  const acronyms = fullText.match(/\\b[A-Z]{2,}\\b/g) || [];\n  for (const acr of acronyms) {\n    if (!seen.has(acr.toLowerCase()) && acr.length >= 2) {\n      seen.add(acr.toLowerCase());\n      extractedEntities.push(acr);\n    }\n  }\n}\n\nconst validEntities = extractedEntities\n  .map(e => e.replace(/[^a-zA-Z\\u00C0-\\u00FF0-9\\-_\\s]/g, '').substring(0, 100))\n  .filter(e => e.length > 2)\n  .slice(0, 20);\n\nif (validEntities.length === 0) {\n  return [{\n    json: {\n      skip_neo4j: true,\n      reason: 'No valid entities extracted from text or JSON',\n      hyde_document: hydeDocument || rawContent\n    }\n  }];\n}\n\nconst MAX_DEPTH = 3;\nconst MAX_RESULTS = 100;\n\nconst correctedQuery = `\nMATCH (n)\nWHERE ((n.name IN $entity_names\n      OR ANY(ename IN $entity_names WHERE toLower(n.name) CONTAINS toLower(ename))\n      OR ANY(ename IN $entity_names WHERE toLower(ename) CONTAINS toLower(n.name)))\n      OR toLower(n.name) IN [x IN $entity_names | toLower(x)]\n      OR ANY(ename IN $entity_names WHERE size(ename) > 3 AND toLower(n.name) CONTAINS toLower(ename)))\n  AND (n.tenant_id = $tenant_id OR n.tenant_id IS NULL)\nWITH n,\n     CASE\n       WHEN n:Organization THEN 1.3\n       WHEN n:Person THEN 1.2\n       WHEN n:City THEN 1.1\n       WHEN n:Museum THEN 1.2\n       WHEN n:Technology THEN 1.0\n       WHEN n:Disease THEN 1.0\n       ELSE 0.9\n     END as entity_priority\nORDER BY entity_priority DESC\nLIMIT 10\n\nOPTIONAL MATCH path = (n)-[r*1..${MAX_DEPTH}]-(m)\nWHERE (m.tenant_id = $tenant_id OR m.tenant_id IS NULL)\nWITH path, n as startNode, entity_priority,\n     reduce(score = entity_priority, rel IN relationships(path) |\n       score + CASE type(rel)\n         WHEN 'A_CREE' THEN 1.5\n         WHEN 'CAUSE_PAR' THEN 1.4\n         WHEN 'CONNECTE' THEN 1.3\n         WHEN 'PROTEGE_CONTRE' THEN 1.3\n         WHEN 'ETUDIE' THEN 1.2\n         WHEN 'UTILISE' THEN 1.2\n         WHEN 'CIBLE' THEN 1.2\n         WHEN 'EXPOSE_A' THEN 1.1\n         WHEN 'VISE_A_LIMITER' THEN 1.1\n         WHEN 'SOUS_ENSEMBLE_DE' THEN 1.0\n         WHEN 'ETEND' THEN 1.0\n         ELSE 0.8\n       END\n     ) as path_score,\n     length(path) as path_length\n\nWHERE path_score > (path_length * 0.3)\n\nRETURN\n  startNode.name as start_entity,\n  [node IN nodes(path) | {name: node.name, type: labels(node)[0]}] as path_nodes,\n  [rel IN relationships(path) | type(rel)] as path_relations,\n  path_score,\n  path_length\nORDER BY path_score DESC\nLIMIT $max_results\n`;\n\nreturn [{\n  json: {\n    skip_neo4j: false,\n    query: correctedQuery,\n    parameters: {\n      entity_names: validEntities,\n      tenant_id: initData.user_context?.tenant_id || 'benchmark',\n      max_results: MAX_RESULTS\n    },\n    hyde_document: hydeDocument || rawContent,\n    entities: validEntities,\n    traversal_config: { max_depth: MAX_DEPTH },\n    _debug: {\n      entities_found: validEntities.length,\n      extraction_method: 'nlp_fallback',\n      neo4j_5x_compatible: true\n    }\n  }\n}];",
        "options": {
          "timeout": 15000
        }
      },
      "id": "a8754cb4-d0ae-4e01-8f88-a233de357eb1",
      "name": "Neo4j Query Builder (Deep Traversal V2)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        528,
        6192
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.NEO4J_URL }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { statement: $json.query, parameters: $json.parameters ?? {} } }}",
        "options": {
          "timeout": 15000
        }
      },
      "id": "80d46e98-cc4e-4719-9f36-9baa360839b7",
      "name": "Shield #4: Neo4j Guardian Traversal",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        672,
        5968
      ],
      "credentials": {
        "httpBasicAuth": {
          "id": "1p9NvJFmJsjSYq1J",
          "name": "Unnamed credential"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.PINECONE_URL }}/query",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"vector\": {{ JSON.stringify($node['Validate Embedding'].json.embedding || $node['Generate HyDE Embedding'].json.embeddings?.float?.[0] || []) }},\n  \"topK\": {{ $node['OTEL Init'].json.topK || 100 }},\n  \"includeMetadata\": true\n}",
        "options": {
          "timeout": 15000
        }
      },
      "id": "8714e649-b33f-412c-a880-ee3fd1e5e0f2",
      "name": "WF3: Pinecone HyDE Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        896,
        6688
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "3DEiHDwB09D65919",
          "name": "Pinecone API Key"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT summary, relevance_score, entity_names \nFROM community_summaries \nWHERE entity_names && ARRAY[{{ $('Neo4j Query Builder (Deep Traversal V2)').json.entities.map(e => \"'\" + e.replace(/'/g, \"''\") + \"'\").join(',') }}]::text[]\n  AND tenant_id = '{{ $('OTEL Init').json.user_context.tenant_id }}'\nORDER BY relevance_score DESC \nLIMIT 5",
        "options": {}
      },
      "id": "9b146d4b-cf1d-4ecd-aaf0-2b7599620c8c",
      "name": "Community Summaries Fetch",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        752,
        6256
      ],
      "credentials": {
        "postgres": {
          "id": "zEr7jPswZNv6lWKu",
          "name": "Supabase PostgreSQL"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Merge for Deep Traversal Results - CONFIRMÃ‰\n// Handles paths up to 4 hops with intelligent deduplication\n\n// === COLLECT ALL SOURCES ===\nlet graphResults = [];\nlet vectorResults = [];\nlet communityResults = [];\n\n// Graph Results (from Deep Traversal)\ntry {\n  const neo4jData = $node['Shield #4: Neo4j Guardian Traversal'].json;\n  \n  let rows = [];\n  if (neo4jData.data?.values?.length > 0) {\n    // Neo4j query/v2 API format\n    rows = neo4jData.data.values;\n  } else if (neo4jData.results?.[0]?.data) {\n    rows = neo4jData.results[0].data.map(d => d.row);\n  } else if (neo4jData.body?.data?.values?.length > 0) {\n    rows = neo4jData.body.data.values;\n  } else if (neo4jData.body?.results?.[0]?.data) {\n    rows = neo4jData.body.results[0].data.map(d => d.row);\n  } else if (Array.isArray(neo4jData.body)) {\n    rows = neo4jData.body;\n  } else if (Array.isArray(neo4jData)) {\n    rows = neo4jData;\n  }\n  \n  if (rows.length > 0) {\n    graphResults = rows.map((row, idx) => {\n      const pathNodes = Array.isArray(row) ? row[1] : row.path_nodes;\n      const pathRelations = Array.isArray(row) ? row[2] : row.path_relations;\n      const pathScore = Array.isArray(row) ? row[3] : row.path_score;\n      const pathLength = Array.isArray(row) ? row[4] : row.path_length;\n      \n      return {\n        source: 'GRAPH',\n        id: `graph-${idx}`,\n        content: formatGraphPath(pathNodes, pathRelations),\n        path_nodes: pathNodes || [],\n        path_relations: pathRelations || [],\n        path_score: pathScore || 1.0,\n        path_length: pathLength || 1,\n        start_entity: Array.isArray(row) ? row[0] : row.start_entity\n      };\n    });\n  }\n} catch (e) { \n  console.log('Graph parse error:', e.message); \n}\n\n// Vector Results (Pinecone)\ntry {\n  const pineconeData = (() => {\n  try { return $node['WF3: Pinecone HyDE Search'].json; }\n  catch(e) { return { matches: [] }; }\n})();\n  const matches = pineconeData.body?.matches || pineconeData.matches || [];\n  vectorResults = matches.map((m, idx) => ({\n    source: 'VECTOR',\n    id: m.id || `vector-${idx}`,\n    content: m.metadata?.text || m.metadata?.content || '',\n    score: m.score || 0,\n    metadata: m.metadata\n  }));\n} catch (e) { \n  console.log('Vector parse error:', e.message); \n}\n\n// Community Summaries\ntry {\n  const communityData = $node['Community Summaries Fetch'].json;\n  const commArray = Array.isArray(communityData) ? communityData : \n                    (communityData ? [communityData] : []);\n  communityResults = commArray\n    .filter(c => c && c.summary)\n    .map((c, idx) => ({\n      source: 'COMMUNITY',\n      id: c.community_id || `comm-${idx}`,\n      content: c.summary || '',\n      title: c.title,\n      entity_count: c.entity_count\n    }));\n} catch (e) { \n  console.log('Community parse error:', e.message); \n}\n\n// === HELPER: Format graph path for reading ===\nfunction formatGraphPath(nodes, relations) {\n  if (!nodes || nodes.length === 0) return '';\n  \n  let pathStr = nodes[0]?.name || (typeof nodes[0] === 'string' ? nodes[0] : 'Unknown');\n  \n  for (let i = 0; i < (relations?.length || 0) && i < nodes.length - 1; i++) {\n    const nextNode = nodes[i + 1]?.name || (typeof nodes[i + 1] === 'string' ? nodes[i + 1] : 'Unknown');\n    pathStr += ` --[${relations[i]}]--> ${nextNode}`;\n  }\n  return pathStr;\n}\n\n// === DEDUPLICATION & SCORING ===\nconst allResults = [...graphResults, ...vectorResults, ...communityResults];\n\nconst maxGraphScore = Math.max(...graphResults.map(r => r.path_score || 0), 1);\nconst maxVectorScore = Math.max(...vectorResults.map(r => r.score || 0), 1);\n\nconst normalizedResults = allResults.map(r => {\n  let normalizedScore = 0;\n  if (r.source === 'GRAPH') {\n    normalizedScore = (r.path_score / maxGraphScore) * (1 / (r.path_length * 0.3 + 0.7));\n  } else if (r.source === 'VECTOR') {\n    normalizedScore = r.score / maxVectorScore;\n  } else {\n    normalizedScore = 0.5;\n  }\n  return { ...r, normalized_score: normalizedScore };\n});\n\nnormalizedResults.sort((a, b) => b.normalized_score - a.normalized_score);\n\nconst finalResults = [];\nconst sourceCounts = { GRAPH: 0, VECTOR: 0, COMMUNITY: 0 };\nconst MAX_PER_SOURCE = 15;\nconst TOTAL_MAX = 30;\n\nfor (const result of normalizedResults) {\n  if (finalResults.length >= TOTAL_MAX) break;\n  if (sourceCounts[result.source] < MAX_PER_SOURCE) {\n    finalResults.push(result);\n    sourceCounts[result.source]++;\n  }\n}\n\n// === OUTPUT ===\nreturn [{\n  json: {\n    merged_results: finalResults,\n    source_counts: sourceCounts,\n    total_count: finalResults.length,\n    traversal_depth_used: Math.max(...graphResults.map(r => r.path_length || 0), 0),\n    hyde_document: (() => {\n      try {\n        const parsed = JSON.parse($node['WF3: HyDE & Entity Extraction'].json.choices[0].message.content || '{}');\n        return parsed.hyde_document || '';\n      } catch(e) {\n        // LLM returned plain text, not JSON - use the raw text as HyDE document\n        return $node['WF3: HyDE & Entity Extraction'].json.choices?.[0]?.message?.content || $node['OTEL Init'].json.query || '';\n      }\n    })()\n  }\n}];"
      },
      "id": "bc35ece7-e92d-4106-9c9f-05518d0da52e",
      "name": "Merge Graph + Vector + Community (Deep)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        6320
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.RERANKER_API_URL || 'https://api.cohere.ai/v1/rerank' }}",
        "authentication": "none",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"{{ $vars.RERANKER_MODEL || 'rerank-multilingual-v3.0' }}\",\n  \"query\": \"{{ $node['OTEL Init'].json.query }}\",\n  \"documents\": {{ JSON.stringify(($json.merged_results || []).map(d => d.content || '').filter(c => c.length > 0).slice(0, 25)) }},\n  \"top_n\": 10\n}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 3000
            }
          },
          "timeout": 15000
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $vars.COHERE_API_KEY }}"
            }
          ]
        }
      },
      "id": "607cef8e-6604-49a2-bf00-2bbc64fbd6d4",
      "name": "WF3: Cohere Reranker",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1376,
        6320
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Reranker fallback handler - CORRIGÃ‰\nconst rerankedResults = $json.results || [];\nconst mergeData = $node['Merge Graph + Vector + Community (Deep)'].json;\n\nreturn [{\n  json: {\n    reranked_results: rerankedResults,\n    merged_results: mergeData.merged_results || [],\n    source_counts: mergeData.source_counts || {},\n    traversal_depth: mergeData.traversal_depth_used || 0,\n    fallback: rerankedResults.length === 0\n  }\n}];"
      },
      "id": "7a948764-76a8-4062-a66c-55db8e797232",
      "name": "Reranker Fallback Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1584,
        6304
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// PATCH 3.4: Token Budgeting & Map-Reduce for Large Contexts - CORRIGÃ‰\nconst MAX_TOKENS = 6000;\nconst CHARS_PER_TOKEN = 4;\n\nconst mergedResults = $json.merged_results || [];\nconst rerankedResults = $json.reranked_results || [];\n\nlet budget = MAX_TOKENS;\nconst allocated = { \n  reranked: [], \n  graph: [], \n  vector: [], \n  community: [] \n};\n\n// Allocate reranked first (highest priority)\nfor (const item of rerankedResults.slice(0, 5)) {\n  const content = typeof item === 'string' ? item : (item.document || item.content || '');\n  const tokens = Math.ceil(content.length / CHARS_PER_TOKEN);\n  if (budget >= tokens) {\n    allocated.reranked.push(item);\n    budget -= tokens;\n  }\n}\n\n// Allocate remaining results by source\nfor (const result of mergedResults) {\n  const tokens = Math.ceil((result.content?.length || 0) / CHARS_PER_TOKEN);\n  if (budget < tokens) continue;\n  \n  if (result.source === 'GRAPH' && allocated.graph.length < 10) {\n    allocated.graph.push(result);\n    budget -= tokens;\n  } else if (result.source === 'VECTOR' && allocated.vector.length < 10) {\n    allocated.vector.push(result);\n    budget -= tokens;\n  } else if (result.source === 'COMMUNITY' && allocated.community.length < 5) {\n    allocated.community.push(result);\n    budget -= tokens;\n  }\n}\n\n// Build compact relationship string from graph results\nconst relationships = allocated.graph\n  .filter(g => g.path_relations && g.path_nodes)\n  .map(g => {\n    const nodes = g.path_nodes || [];\n    const rels = g.path_relations || [];\n    if (nodes.length < 2) return null;\n    return `${nodes[0]?.name || 'Unknown'}-[${rels[0] || '?'}]->${nodes[1]?.name || 'Unknown'}`;\n  })\n  .filter(r => r !== null)\n  .slice(0, 20)\n  .join('; ');\n\nreturn [{\n  json: {\n    budgeted_context: {\n      reranked: allocated.reranked,\n      graph: allocated.graph,\n      vector: allocated.vector,\n      community: allocated.community,\n      relationships: relationships\n    },\n    tokens_used: MAX_TOKENS - budget,\n    tokens_remaining: budget,\n    fallback: $json.fallback || false,\n    traversal_depth: $json.traversal_depth || 0\n  }\n}];"
      },
      "id": "31aa61de-dd88-4c0b-884a-32f85142b63e",
      "name": "JS: Token Budgeting & Map-Reduce",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        6304
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Response Formatter - builds LLM Answer Synthesis request body\n// Handles missing vector results when embedding credits are exhausted\n\n// Safely get reranked vector results\nlet vectorResults = [];\ntry {\n  vectorResults = $node['WF3: Cohere Reranker']?.json?.results || [];\n} catch(e) {\n  vectorResults = [];\n}\n\n// Safely get Neo4j data\nlet neo4jData = null;\ntry {\n  neo4jData = $node['Validate Neo4j Results']?.json;\n} catch(e) {}\n\n// Safely get community data\nlet communityData = null;\ntry {\n  communityData = $node['Community Summaries Fetch']?.json;\n} catch(e) {}\n\n// Safely get entity extraction data\nlet entityData = null;\ntry {\n  entityData = $node['WF3: HyDE & Entity Extraction']?.json;\n} catch(e) {}\n\n// Build context from all available sources\nconst ctx = $json.budgeted_context || {};\nconst query = $node['OTEL Init'].json.query;\nconst traceId = $node['OTEL Init'].json.trace_id || '';\nconst contextParts = [];\n\n// Graph relationships from budgeted context\nif (ctx.relationships) {\n  contextParts.push('Graph Relationships: ' + ctx.relationships);\n}\nif (ctx.graph && ctx.graph.length > 0) {\n  const graphText = ctx.graph.slice(0, 5).map(g => g.content || g.text || '').filter(Boolean).join('\\n');\n  if (graphText) contextParts.push('Graph Context:\\n' + graphText);\n}\n\n// Vector/reranked docs\nif (ctx.reranked && ctx.reranked.length > 0) {\n  const rerankedText = ctx.reranked.slice(0, 5).map((d, i) => {\n    const content = typeof d === 'string' ? d : (d.document || d.content || d.text || '');\n    return '[Doc ' + (i+1) + '] ' + content;\n  }).filter(Boolean).join('\\n');\n  if (rerankedText) contextParts.push('Relevant Documents:\\n' + rerankedText);\n}\n\n// Community summaries\nif (ctx.community && ctx.community.length > 0) {\n  const commText = ctx.community.slice(0, 3).map(c => c.content || c.text || '').filter(Boolean).join('\\n');\n  if (commText) contextParts.push('Community Summaries:\\n' + commText);\n}\n\n// Fallback: if no budgeted context, try raw Neo4j data\nif (contextParts.length === 0) {\n  if (neo4jData && !neo4jData.skip_graph) {\n    // Extract paths from Neo4j v2 format\n    const values = neo4jData.data?.values || neo4jData.results?.[0]?.data?.map(d => d.row) || [];\n    if (values.length > 0) {\n      const pathStr = values.slice(0, 10).map(row => {\n        if (Array.isArray(row)) {\n          const startEntity = row[0];\n          const pathNodes = row[1] || [];\n          const pathRels = row[2] || [];\n          const nodeNames = Array.isArray(pathNodes) ? pathNodes.map(n => n.name || n).join(' -> ') : String(pathNodes);\n          return startEntity + ': ' + nodeNames + ' [' + (Array.isArray(pathRels) ? pathRels.join(', ') : '') + ']';\n        }\n        return JSON.stringify(row).substring(0, 200);\n      }).join('\\n');\n      contextParts.push('Entity Graph Paths:\\n' + pathStr);\n    }\n  }\n  \n  // Try community summaries raw data\n  if (communityData) {\n    const summaries = communityData.summaries || communityData;\n    if (Array.isArray(summaries) && summaries.length > 0) {\n      const commStr = summaries.slice(0, 3).map(s => s.summary || s.content || JSON.stringify(s).substring(0, 300)).join('\\n');\n      contextParts.push('Community Summaries:\\n' + commStr);\n    }\n  }\n  \n  // Try Hyde document as last resort context\n  if (contextParts.length === 0 && entityData) {\n    const content = entityData.choices?.[0]?.message?.content || '';\n    try {\n      const parsed = JSON.parse(content);\n      if (parsed.hyde_document) {\n        contextParts.push('Background Knowledge:\\n' + parsed.hyde_document);\n      }\n    } catch(e) {\n      if (content.length > 20) {\n        contextParts.push('Background Knowledge:\\n' + content.substring(0, 1000));\n      }\n    }\n  }\n}\n\nconst fullContext = contextParts.join('\\n\\n');\nconst embedding_fallback = vectorResults.length === 0;\nconst traversal_depth = ctx.graph?.length || 0;\nconst context_sources = contextParts.length;\n\n// Build request body for LLM Answer Synthesis\nconst requestBody = {\n  model: 'arcee-ai/trinity-large-preview:free',\n  messages: [\n    {\n      role: 'system',\n      content: 'You are a precise knowledge graph assistant. Answer questions using ONLY the provided context. For factual questions (who/what/where/when), answer in 1-5 words. For yes/no questions, start with Yes or No. For numerical questions, give the number with unit. NEVER say you lack information - always provide your best answer from the context. Respond in the SAME LANGUAGE as the question.'\n    },\n    {\n      role: 'user',\n      content: 'Context:\\n' + fullContext + '\\n\\nQuestion: ' + query + '\\n\\nAnswer concisely:'\n    }\n  ],\n  temperature: 0.1,\n  max_tokens: 300\n};\n\nreturn [{\n  json: {\n    requestBody: requestBody,\n    trace_id: traceId,\n    embedding_fallback: embedding_fallback,\n    tokens_used: 0,\n    traversal_depth: traversal_depth,\n    context_sources: context_sources,\n    debug_context_length: fullContext.length,\n    debug_context_parts: contextParts.length\n  }\n}];"
      },
      "id": "0520b590-2736-4e0e-9191-0cb6ac9cce39",
      "name": "Response Formatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        6304
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.OTEL_COLLECTOR_URL || 'https://otel-collector.internal' }}/v1/traces",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"traceId\": \"={{ $json.trace_id }}\",\n  \"spanName\": \"graph_rag_complete\",\n  \"status\": \"={{ $json.status }}\"\n}",
        "options": {
          "timeout": 5000
        }
      },
      "id": "5767bffd-b95a-4837-ae02-871f103c9944",
      "name": "Shield #9: Export Trace",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2160,
        6304
      ],
      "disabled": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "content": "# ðŸ”§ VARIABLES D'ENVIRONNEMENT (SOTA 2026) - CORRECTED V3.3.1\n\n## CORRECTIONS APPLIQUÃ‰ES:\n1. âœ… OTEL Init: Fixed duplicate 'const query' declaration\n2. âœ… WF3: Cohere Reranker: Fixed triple nested template\n3. âœ… Model references updated for OpenRouter format\n\n## LLM APIs\n- `OPENROUTER_BASE_URL` - https://openrouter.ai/api/v1/chat/completions\n- `LLM_HYDE_MODEL` - google/gemini-2.0-flash-exp\n\n## Databases\n- `NEO4J_URL` - Neo4j HTTP API URL\n- `PINECONE_URL` - Pinecone query endpoint\n\n## Reranking\n- `RERANKER_API_URL` - https://api.cohere.ai/v1/rerank\n- `RERANKER_MODEL` - rerank-multilingual-v3.0\n",
        "height": 500,
        "width": 400
      },
      "id": "06eeed8a-47ad-49e4-94be-59effdb952c8",
      "name": "ðŸ“‹ Configuration SOTA 2026",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -544,
        6176
      ]
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -80,
        6416
      ],
      "id": "fb3ea9ac-ff4c-411c-8ea0-ed74b27af584",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "public": true,
        "availableInChat": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.4,
      "position": [
        -48,
        6608
      ],
      "id": "0735714d-f746-45d8-add1-bdcd8eee651f",
      "name": "When chat message received",
      "webhookId": "d4017c54-b97c-44ea-b3e8-856b500eb665"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ff622742-6d71-4e91-af71-b5c666088717",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -96,
        6240
      ],
      "id": "d8c31157-76d1-4bb1-90be-671b77740e9e",
      "name": "Webhook",
      "webhookId": "ff622742-6d71-4e91-af71-b5c666088717"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.EMBEDDING_API_URL || 'https://api.cohere.com/v2/embed' }}",
        "authentication": "none",
        "nodeCredentialType": "openRouterApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"model\": ($vars.EMBEDDING_MODEL || 'embed-english-v3.0'), \"texts\": [$json.hyde_document], \"input_type\": \"search_query\", \"embedding_types\": [\"float\"] } }}",
        "options": {
          "retry": {
            "maxTries": 3,
            "waitBetweenTries": 2000
          }
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $vars.COHERE_API_KEY }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        496,
        6688
      ],
      "id": "aae84d9a-da5e-4949-a6ed-9e696d260f95",
      "name": "Generate HyDE Embedding",
      "credentials": {},
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Extract HyDE Document - handles both JSON and plain text responses\nlet hydeDocument = '';\nconst rawContent = $json.choices?.[0]?.message?.content || '';\n\n// Strategy 1: Try JSON parse (model may output structured JSON)\ntry {\n  const parsed = JSON.parse(rawContent);\n  hydeDocument = parsed.hyde_document || '';\n} catch (e) {\n  // Strategy 2: Try to find JSON embedded in text\n  const jsonMatch = rawContent.match(/\\{[\\s\\S]*\"hyde_document\"[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    try {\n      const embedded = JSON.parse(jsonMatch[0]);\n      hydeDocument = embedded.hyde_document || '';\n    } catch (e2) {}\n  }\n}\n\n// Strategy 3: Use raw text as HyDE document (it IS a good hypothetical doc)\nif (!hydeDocument || hydeDocument.length < 10) {\n  hydeDocument = rawContent.replace(/```json[\\s\\S]*?```/g, '').trim();\n}\n\n// Final fallback to original query\nif (!hydeDocument || hydeDocument.length < 10) {\n  hydeDocument = $node['OTEL Init'].json.query;\n}\n\nreturn [{\n  json: {\n    hyde_document: hydeDocument,\n    original_query: $node['OTEL Init'].json.query,\n    hyde_success: hydeDocument !== $node['OTEL Init'].json.query && hydeDocument.length > 50\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        6688
      ],
      "id": "151d0ab0-4d4c-4d59-b7e1-833f025720be",
      "name": "Extract HyDE Document",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Validate Neo4j Results - handles both REST and query/v2 API formats\nconst neo4jData = $json;\n\nlet hasResults = false;\nlet errorMessage = null;\n\n// Check for errors\nif (neo4jData.errors && neo4jData.errors.length > 0) {\n  errorMessage = neo4jData.errors[0].message;\n}\n\n// Check for results in different formats\n// Format 1: REST API (results[0].data)\nif (neo4jData.results?.[0]?.data?.length > 0) {\n  hasResults = true;\n}\n// Format 2: Query v2 API (data.values)\nif (neo4jData.data?.values?.length > 0) {\n  hasResults = true;\n}\n// Format 3: body wrapper\nif (neo4jData.body?.results?.[0]?.data?.length > 0) {\n  hasResults = true;\n}\nif (neo4jData.body?.data?.values?.length > 0) {\n  hasResults = true;\n}\n\nif (!hasResults) {\n  return [{\n    json: {\n      skip_graph: true,\n      error: errorMessage,\n      results: { results: [{ data: [] }] }\n    }\n  }];\n}\n\nreturn [{ json: neo4jData }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        5968
      ],
      "id": "a556d066-841a-4dbb-9c8b-fb78c7e0d224",
      "name": "Validate Neo4j Results",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const embeddingData = $json;\n\n// Check if we have a valid embedding - handle both Cohere and OpenRouter formats\nlet embedding = [];\n\n// Cohere v2 format: embeddings.float[0]\nif (embeddingData.embeddings?.float?.[0]) {\n  embedding = embeddingData.embeddings.float[0];\n}\n// OpenRouter/OpenAI format: data[0].embedding\nelse if (embeddingData.data?.[0]?.embedding) {\n  embedding = embeddingData.data[0].embedding;\n}\n// Body wrapper variants\nelse if (embeddingData.body?.embeddings?.float?.[0]) {\n  embedding = embeddingData.body.embeddings.float[0];\n}\nelse if (embeddingData.body?.data?.[0]?.embedding) {\n  embedding = embeddingData.body.data[0].embedding;\n}\nelse if (Array.isArray(embeddingData.embedding)) {\n  embedding = embeddingData.embedding;\n}\n\n// Validate embedding dimensions (1024 for Cohere, 1536 for OpenAI)\nconst expectedDims = parseInt($vars.EMBEDDING_DIMS || '1024');\nconst isValid = embedding.length >= 384; // Accept any reasonable dimension\n\nif (!isValid) {\n  return [{\n    json: {\n      valid: false,\n      error: `Invalid embedding: got ${embedding.length}, expected ${expectedDims}`,\n      embedding: [],\n      fallback: true\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    valid: true,\n    embedding: embedding,\n    dimensions: embedding.length\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        6688
      ],
      "id": "46cf3f08-8e8f-4722-84e4-719684a5ea2b",
      "name": "Validate Embedding",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        960,
        6432
      ],
      "id": "08524ce1-8a7e-4ce4-a9bb-4745270a4c2c",
      "name": "Merge",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.OPENROUTER_BASE_URL || 'https://openrouter.ai/api/v1/chat/completions' }}",
        "authentication": "none",
        "nodeCredentialType": "openRouterApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
        "options": {
          "timeout": 30000,
          "retry": {
            "maxTries": 1,
            "waitBetweenTries": 5000
          }
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $vars.OPENROUTER_API_KEY }}"
            }
          ]
        }
      },
      "id": "a1b2c3d4-llm-answer-synthesis",
      "name": "LLM Answer Synthesis",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2080,
        6304
      ],
      "credentials": {},
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Extract LLM answer and format final response\n// Handle rate limit errors gracefully\nconst llmResponse = $json;\nlet answer = '';\n\nif (llmResponse.error) {\n  // LLM call failed - try to extract partial info from context\n  const ctx = $node['Response Formatter']?.json || {};\n  // Try to extract answer from context even if LLM failed\n    const ctxFallback = $node['Response Formatter']?.json || {};\n    const contextText = ctxFallback.context || '';\n    if (contextText.length > 20) {\n      // Use first meaningful sentence from context as answer\n      const sentences = contextText.split(/[.!?]/).filter(s => s.trim().length > 10);\n      answer = sentences.slice(0, 2).join('. ').trim() + '.';\n    } else {\n      answer = 'Information not available in the knowledge graph.';\n    }\n} else {\n  answer = llmResponse.choices?.[0]?.message?.content || '';\n}\n\nif (!answer || answer.trim() === '') {\n  answer = 'No answer generated';\n}\n\nconst contextData = $node['Response Formatter']?.json || {};\n\nreturn [{ json: {\n  status: answer !== 'No answer generated' ? 'SUCCESS' : 'NO_ANSWER',\n  trace_id: contextData.trace_id || '',\n  response: answer.trim(),\n  metadata: {\n    source: 'graph_rag_llm_synthesis',\n    tokens_used: contextData.tokens_used || 0,\n    traversal_depth: contextData.traversal_depth || 0,\n    context_sources: contextData.context_sources || 0\n  }\n} }];"
      },
      "id": "e5f6g7h8-answer-formatter",
      "name": "Answer Formatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2280,
        6304
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "id": "r1s2t3u4-respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2480,
        6304
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// GitHub Error Logger for graph\nconst errorData = $input.first().json;\nconst timestamp = new Date().toISOString();\nconst questionId = errorData.question_id || errorData.trace_id || 'q-' + Date.now();\nconst errorType = errorData.error_type || errorData.error_code || 'UNKNOWN';\nconst pipeline = 'graph';\n\nconst logEntry = {\n  timestamp: timestamp,\n  pipeline: pipeline,\n  question_id: questionId,\n  error_type: errorType,\n  error_message: (errorData.error || errorData.message || 'No message').slice(0, 500),\n  input: {\n    query: (errorData.query || errorData.original_query || '').slice(0, 300),\n    tenant_id: errorData.tenant_id || 'benchmark'\n  },\n  partial_response: errorData.partial_response || errorData.response || null,\n  n8n_context: {\n    workflow_id: $workflow.id,\n    workflow_name: $workflow.name,\n    execution_id: $execution.id\n  },\n  performance: {\n    latency_ms: errorData.latency_ms || 0,\n    http_status: errorData.http_status || null\n  }\n};\n\nreturn [{ json: logEntry }];"
      },
      "id": "ab13bde8-d072-4213-82eb-019c383cf22a",
      "name": "GitHub Error Logger (graph)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2780,
        0
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Entity Extraction Logger\nconst input = $input.first().json;\nconst entities = input.entities || input.parameters?.entity_names || [];\nconst skipNeo4j = input.skip_neo4j || false;\n\nconst log = {\n  timestamp: new Date().toISOString(),\n  pipeline: 'graph',\n  step: 'entity_extraction',\n  query: (input.query_text || input.query || '').slice(0, 300),\n  entities_extracted: entities,\n  entity_count: entities.length,\n  skip_neo4j: skipNeo4j,\n  hyde_preview: (input.hyde_document || '').slice(0, 200)\n};\n\n// Pass through original data + log\nreturn [{ json: { ...input, _entity_log: log } }];"
      },
      "id": "670719ff-3e44-4f90-bb2b-78bd7d447a8d",
      "name": "Entity Extraction Logger",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2780,
        200
      ],
      "onError": "continueRegularOutput"
    }
  ],
  "connections": {
    "OTEL Init": {
      "main": [
        [
          {
            "node": "WF3: HyDE & Entity Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "WF3: HyDE & Entity Extraction": {
      "main": [
        [
          {
            "node": "Extract HyDE Document",
            "type": "main",
            "index": 0
          },
          {
            "node": "Neo4j Query Builder (Deep Traversal V2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Neo4j Query Builder (Deep Traversal V2)": {
      "main": [
        [
          {
            "node": "Shield #4: Neo4j Guardian Traversal",
            "type": "main",
            "index": 0
          },
          {
            "node": "Community Summaries Fetch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shield #4: Neo4j Guardian Traversal": {
      "main": [
        [
          {
            "node": "Validate Neo4j Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "WF3: Pinecone HyDE Search": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Community Summaries Fetch": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Graph + Vector + Community (Deep)": {
      "main": [
        [
          {
            "node": "WF3: Cohere Reranker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "WF3: Cohere Reranker": {
      "main": [
        [
          {
            "node": "Reranker Fallback Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Reranker Fallback Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reranker Fallback Handler": {
      "main": [
        [
          {
            "node": "JS: Token Budgeting & Map-Reduce",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JS: Token Budgeting & Map-Reduce": {
      "main": [
        [
          {
            "node": "Response Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response Formatter": {
      "main": [
        [
          {
            "node": "LLM Answer Synthesis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "OTEL Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "OTEL Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "OTEL Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate HyDE Embedding": {
      "main": [
        [
          {
            "node": "Validate Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract HyDE Document": {
      "main": [
        [
          {
            "node": "Generate HyDE Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Neo4j Results": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Embedding": {
      "main": [
        [
          {
            "node": "WF3: Pinecone HyDE Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Merge Graph + Vector + Community (Deep)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Answer Synthesis": {
      "main": [
        [
          {
            "node": "Answer Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Answer Formatter": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          },
          {
            "node": "Shield #9: Export Trace",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GitHub Error Logger (graph)": {
      "main": [
        [
          {
            "node": "GitHub Error Logger (graph)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false,
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "executionTimeout": 90
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "377c8f45-db4d-405f-a096-b7d25fd0c7ce",
  "activeVersionId": "377c8f45-db4d-405f-a096-b7d25fd0c7ce",
  "versionCounter": 361,
  "triggerCount": 2,
  "shared": [
    {
      "updatedAt": "2026-01-30T16:54:29.975Z",
      "createdAt": "2026-01-30T16:54:29.975Z",
      "role": "workflow:owner",
      "workflowId": "95x2BBAbJlLWZtWEJn6rb",
      "projectId": "JV7MbqBbWPTstXIo",
      "project": {
        "updatedAt": "2026-01-07T13:20:26.996Z",
        "createdAt": "2026-01-07T13:20:21.870Z",
        "id": "JV7MbqBbWPTstXIo",
        "name": "Alexis Moret <alexis.moret6@outlook.fr>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "215767e0-958a-4c74-a67a-e335807eba64",
        "projectRelations": [
          {
            "updatedAt": "2026-01-07T13:20:21.870Z",
            "createdAt": "2026-01-07T13:20:21.870Z",
            "userId": "215767e0-958a-4c74-a67a-e335807eba64",
            "projectId": "JV7MbqBbWPTstXIo",
            "user": {
              "updatedAt": "2026-02-09T23:01:37.000Z",
              "createdAt": "2026-01-07T13:20:20.003Z",
              "id": "215767e0-958a-4c74-a67a-e335807eba64",
              "email": "alexis.moret6@outlook.fr",
              "firstName": "Alexis",
              "lastName": "Moret",
              "personalizationAnswers": null,
              "settings": {
                "userActivated": true,
                "userClaimedAiCredits": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "e3_89vptJG7PPA-OHyAg3",
                "userActivatedAt": 1767837780144,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1768407850905
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-02-09",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-02-10T12:08:29.666Z",
    "createdAt": "2026-02-10T12:08:29.666Z",
    "versionId": "377c8f45-db4d-405f-a096-b7d25fd0c7ce",
    "workflowId": "95x2BBAbJlLWZtWEJn6rb",
    "nodes": [
      {
        "parameters": {
          "jsCode": "// ============================================\n// PATCH #1: INIT & ACL - ORCHESTRATOR SUPPORT\n// ============================================\n// Pour: WF4 Quantitative & WF2 Graph\n// Bug: Workflows Ã©chouent quand appelÃ©s par orchestrateur\n// Fix: Support multi-format d'entrÃ©e\n\n// Init & ACL for RAG - HARDENED V2.2 (ORCHESTRATOR FIX)\nconst rawInput = $input.first().json;\nconst input = rawInput.body || rawInput;\n\n// === EXTRACTION ROBUSTE DE LA QUERY ===\n// Supporte: webhook, chat trigger, sub-workflow, ET orchestrator\nlet queryStr = '';\n\n// PrioritÃ© 1: Direct query field (webhook/chat)\nif (typeof input.query === 'string') {\n  queryStr = input.query;\n}\n// PrioritÃ© 2: Chat input\nelse if (input.chatInput) {\n  queryStr = input.chatInput;\n}\n// PrioritÃ© 3: Orchestrator format - task_query\nelse if (input.task_query) {\n  queryStr = input.task_query;\n}\n// PrioritÃ© 4: Orchestrator format - current_task.query\nelse if (input.current_task && typeof input.current_task.query === 'string') {\n  queryStr = input.current_task.query;\n}\n// PrioritÃ© 5: Query as object (stringify)\nelse if (input.query && typeof input.query === 'object') {\n  queryStr = JSON.stringify(input.query);\n}\n\n// Accept both query and question fields\n// Accept both query and question fields\n// Accept both query and question fields\nconst query = queryStr.trim();\n\n// === VALIDATION ===\nif (!query || query.length < 2) {\n  throw new Error('VALIDATION_ERROR: query is required and must be at least 2 characters');\n}\n\n// === EXTRACTION DU USER CONTEXT ===\n// Parse user_context (peut Ãªtre string JSON ou objet)\nlet userContext = {};\n\nif (typeof input.user_context === 'string') {\n  try {\n    userContext = JSON.parse(input.user_context);\n  } catch (e) {\n    userContext = {};\n  }\n} else if (input.user_context && typeof input.user_context === 'object') {\n  userContext = input.user_context;\n}\n\n// === EXTRACTION DU TRACE_ID ===\n// Support multiple sources\nconst traceId = input.trace_id || \n                input.current_task?.trace_id || \n                `tr-rag-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;\n\n// === OUTPUT ===\nreturn [{\n  json: {\n    trace_id: traceId,\n    query: query.substring(0, 2000),\n    user_context: {\n      tenant_id: userContext.tenant_id || input.tenant_id || 'default',\n      groups: Array.isArray(userContext.groups) ? userContext.groups : ['guest']\n    },\n    timestamp: new Date().toISOString(),\n    source: rawInput.body ? 'webhook' : \n            (rawInput.chatInput ? 'chat' : \n            (input.task_query ? 'orchestrator' : 'subworkflow')),\n    \n    // Metadata pour debugging\n    _debug: {\n      original_input_keys: Object.keys(input),\n      query_source: input.task_query ? 'task_query' : \n                    (input.current_task ? 'current_task.query' : \n                    (input.chatInput ? 'chatInput' : 'query'))\n    }\n  }\n}];\n"
        },
        "id": "0435899c-c6f9-4688-8bec-f0052ec0ecf2",
        "name": "OTEL Init",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          112,
          6400
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $vars.OPENROUTER_BASE_URL || 'https://openrouter.ai/api/v1/chat/completions' }}",
          "authentication": "none",
          "nodeCredentialType": "openRouterApi",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"model\": \"{{ $vars.LLM_HYDE_MODEL || 'google/gemma-3-27b-it:free' }}\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Generate a hypothetical document that would perfectly answer the question. This document will be used for semantic search. Format: dense, factual text, 200-300 words. Also extract key entities as JSON: {\\\"hyde_document\\\": string, \\\"entities\\\": [{\\\"name\\\": string, \\\"type\\\": string}]}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.query }}\"\n    }\n  ],\n  \"temperature\": 0.7,\n  \"max_tokens\": 800\n}",
          "options": {
            "timeout": 25000,
            "retry": {
              "maxTries": 3,
              "waitBetweenTries": 2000
            }
          },
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "=Bearer {{ $vars.OPENROUTER_API_KEY }}"
              }
            ]
          }
        },
        "id": "89b5c399-d785-424c-81d8-312bc84650c1",
        "name": "WF3: HyDE & Entity Extraction",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          288,
          6400
        ],
        "credentials": {},
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Neo4j Query Builder (Deep Traversal V2) - with NLP entity extraction fallback\nconst initData = $node['OTEL Init'].json;\nconst rawContent = $json.choices?.[0]?.message?.content || '';\n\nlet hydeDocument = '';\nlet extractedEntities = [];\n\n// Strategy 1: Try JSON parse\ntry {\n  const parsed = JSON.parse(rawContent);\n  hydeDocument = parsed.hyde_document || '';\n  extractedEntities = (parsed.entities || [])\n    .filter(e => e && typeof e.name === 'string')\n    .map(e => e.name);\n} catch (e) {\n  // Strategy 2: Try embedded JSON\n  const jsonMatch = rawContent.match(/\\{[\\s\\S]*\"entities\"[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    try {\n      const embedded = JSON.parse(jsonMatch[0]);\n      hydeDocument = embedded.hyde_document || '';\n      extractedEntities = (embedded.entities || [])\n        .filter(e => e && typeof e.name === 'string')\n        .map(e => e.name);\n    } catch (e2) {}\n  }\n}\n\n// Strategy 3: NLP-based entity extraction from plain text\nif (extractedEntities.length === 0) {\n  hydeDocument = rawContent;\n  const fullText = rawContent + ' ' + initData.query;\n  \n  const stopWords = new Set([\n    'The', 'What', 'Who', 'Where', 'When', 'How', 'Which', 'Did', 'Does',\n    'Was', 'Were', 'Are', 'Is', 'For', 'This', 'That', 'These', 'Those',\n    'Her', 'His', 'Its', 'She', 'They', 'Not', 'Also', 'Both', 'But',\n    'And', 'Has', 'Had', 'Have', 'Can', 'May', 'Will', 'Our', 'All',\n    'Such', 'Two', 'One', 'First', 'He', 'In', 'As', 'An',\n    'Modern', 'Today', 'Years', 'Only', 'Particularly', 'Remains',\n    'Significant', 'Important', 'Format', 'Throughout', 'Despite',\n    'However', 'Although', 'Furthermore', 'Moreover', 'Additionally',\n    'Meanwhile', 'Nevertheless', 'Consequently', 'Subsequently',\n    'Ultimately', 'Indeed', 'Several', 'Various', 'Numerous',\n    'During', 'Between', 'Within', 'Beyond', 'After', 'Before'\n  ]);\n  \n  const properNouns = fullText.match(/[A-Z\\u00C0-\\u00DC][a-z\\u00E0-\\u00FF]+(?:\\s+[A-Z\\u00C0-\\u00DC][a-z\\u00E0-\\u00FF]+)*/g) || [];\n  \n  const seen = new Set();\n  for (const noun of properNouns) {\n    const clean = noun.trim();\n    if (clean.length > 2 && !stopWords.has(clean) && !seen.has(clean.toLowerCase())) {\n      seen.add(clean.toLowerCase());\n      extractedEntities.push(clean);\n    }\n  }\n  \n  const acronyms = fullText.match(/\\b[A-Z]{2,}\\b/g) || [];\n  for (const acr of acronyms) {\n    if (!seen.has(acr.toLowerCase()) && acr.length >= 2) {\n      seen.add(acr.toLowerCase());\n      extractedEntities.push(acr);\n    }\n  }\n}\n\nconst validEntities = extractedEntities\n  .map(e => e.replace(/[^a-zA-Z\\u00C0-\\u00FF0-9\\-_\\s]/g, '').substring(0, 100))\n  .filter(e => e.length > 2)\n  .slice(0, 20);\n\nif (validEntities.length === 0) {\n  return [{\n    json: {\n      skip_neo4j: true,\n      reason: 'No valid entities extracted from text or JSON',\n      hyde_document: hydeDocument || rawContent\n    }\n  }];\n}\n\nconst MAX_DEPTH = 3;\nconst MAX_RESULTS = 100;\n\nconst correctedQuery = `\nMATCH (n)\nWHERE ((n.name IN $entity_names\n      OR ANY(ename IN $entity_names WHERE toLower(n.name) CONTAINS toLower(ename))\n      OR ANY(ename IN $entity_names WHERE toLower(ename) CONTAINS toLower(n.name)))\n      OR toLower(n.name) IN [x IN $entity_names | toLower(x)]\n      OR ANY(ename IN $entity_names WHERE size(ename) > 3 AND toLower(n.name) CONTAINS toLower(ename)))\n  AND (n.tenant_id = $tenant_id OR n.tenant_id IS NULL)\nWITH n,\n     CASE\n       WHEN n:Organization THEN 1.3\n       WHEN n:Person THEN 1.2\n       WHEN n:City THEN 1.1\n       WHEN n:Museum THEN 1.2\n       WHEN n:Technology THEN 1.0\n       WHEN n:Disease THEN 1.0\n       ELSE 0.9\n     END as entity_priority\nORDER BY entity_priority DESC\nLIMIT 10\n\nOPTIONAL MATCH path = (n)-[r*1..${MAX_DEPTH}]-(m)\nWHERE (m.tenant_id = $tenant_id OR m.tenant_id IS NULL)\nWITH path, n as startNode, entity_priority,\n     reduce(score = entity_priority, rel IN relationships(path) |\n       score + CASE type(rel)\n         WHEN 'A_CREE' THEN 1.5\n         WHEN 'CAUSE_PAR' THEN 1.4\n         WHEN 'CONNECTE' THEN 1.3\n         WHEN 'PROTEGE_CONTRE' THEN 1.3\n         WHEN 'ETUDIE' THEN 1.2\n         WHEN 'UTILISE' THEN 1.2\n         WHEN 'CIBLE' THEN 1.2\n         WHEN 'EXPOSE_A' THEN 1.1\n         WHEN 'VISE_A_LIMITER' THEN 1.1\n         WHEN 'SOUS_ENSEMBLE_DE' THEN 1.0\n         WHEN 'ETEND' THEN 1.0\n         ELSE 0.8\n       END\n     ) as path_score,\n     length(path) as path_length\n\nWHERE path_score > (path_length * 0.3)\n\nRETURN\n  startNode.name as start_entity,\n  [node IN nodes(path) | {name: node.name, type: labels(node)[0]}] as path_nodes,\n  [rel IN relationships(path) | type(rel)] as path_relations,\n  path_score,\n  path_length\nORDER BY path_score DESC\nLIMIT $max_results\n`;\n\nreturn [{\n  json: {\n    skip_neo4j: false,\n    query: correctedQuery,\n    parameters: {\n      entity_names: validEntities,\n      tenant_id: initData.user_context?.tenant_id || 'benchmark',\n      max_results: MAX_RESULTS\n    },\n    hyde_document: hydeDocument || rawContent,\n    entities: validEntities,\n    traversal_config: { max_depth: MAX_DEPTH },\n    _debug: {\n      entities_found: validEntities.length,\n      extraction_method: 'nlp_fallback',\n      neo4j_5x_compatible: true\n    }\n  }\n}];",
          "options": {
            "timeout": 15000
          }
        },
        "id": "a8754cb4-d0ae-4e01-8f88-a233de357eb1",
        "name": "Neo4j Query Builder (Deep Traversal V2)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          528,
          6192
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $vars.NEO4J_URL }}",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpBasicAuth",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { statement: $json.query, parameters: $json.parameters ?? {} } }}",
          "options": {
            "timeout": 15000
          }
        },
        "id": "80d46e98-cc4e-4719-9f36-9baa360839b7",
        "name": "Shield #4: Neo4j Guardian Traversal",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          672,
          5968
        ],
        "credentials": {
          "httpBasicAuth": {
            "id": "1p9NvJFmJsjSYq1J",
            "name": "Unnamed credential"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $vars.PINECONE_URL }}/query",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"vector\": {{ JSON.stringify($node['Validate Embedding'].json.embedding || $node['Generate HyDE Embedding'].json.embeddings?.float?.[0] || []) }},\n  \"topK\": {{ $node['OTEL Init'].json.topK || 100 }},\n  \"includeMetadata\": true\n}",
          "options": {
            "timeout": 15000
          }
        },
        "id": "8714e649-b33f-412c-a880-ee3fd1e5e0f2",
        "name": "WF3: Pinecone HyDE Search",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          896,
          6688
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "3DEiHDwB09D65919",
            "name": "Pinecone API Key"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "operation": "executeQuery",
          "query": "=SELECT summary, relevance_score, entity_names \nFROM community_summaries \nWHERE entity_names && ARRAY[{{ $('Neo4j Query Builder (Deep Traversal V2)').json.entities.map(e => \"'\" + e.replace(/'/g, \"''\") + \"'\").join(',') }}]::text[]\n  AND tenant_id = '{{ $('OTEL Init').json.user_context.tenant_id }}'\nORDER BY relevance_score DESC \nLIMIT 5",
          "options": {}
        },
        "id": "9b146d4b-cf1d-4ecd-aaf0-2b7599620c8c",
        "name": "Community Summaries Fetch",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.4,
        "position": [
          752,
          6256
        ],
        "credentials": {
          "postgres": {
            "id": "zEr7jPswZNv6lWKu",
            "name": "Supabase PostgreSQL"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Enhanced Merge for Deep Traversal Results - CONFIRMÃ‰\n// Handles paths up to 4 hops with intelligent deduplication\n\n// === COLLECT ALL SOURCES ===\nlet graphResults = [];\nlet vectorResults = [];\nlet communityResults = [];\n\n// Graph Results (from Deep Traversal)\ntry {\n  const neo4jData = $node['Shield #4: Neo4j Guardian Traversal'].json;\n  \n  let rows = [];\n  if (neo4jData.data?.values?.length > 0) {\n    // Neo4j query/v2 API format\n    rows = neo4jData.data.values;\n  } else if (neo4jData.results?.[0]?.data) {\n    rows = neo4jData.results[0].data.map(d => d.row);\n  } else if (neo4jData.body?.data?.values?.length > 0) {\n    rows = neo4jData.body.data.values;\n  } else if (neo4jData.body?.results?.[0]?.data) {\n    rows = neo4jData.body.results[0].data.map(d => d.row);\n  } else if (Array.isArray(neo4jData.body)) {\n    rows = neo4jData.body;\n  } else if (Array.isArray(neo4jData)) {\n    rows = neo4jData;\n  }\n  \n  if (rows.length > 0) {\n    graphResults = rows.map((row, idx) => {\n      const pathNodes = Array.isArray(row) ? row[1] : row.path_nodes;\n      const pathRelations = Array.isArray(row) ? row[2] : row.path_relations;\n      const pathScore = Array.isArray(row) ? row[3] : row.path_score;\n      const pathLength = Array.isArray(row) ? row[4] : row.path_length;\n      \n      return {\n        source: 'GRAPH',\n        id: `graph-${idx}`,\n        content: formatGraphPath(pathNodes, pathRelations),\n        path_nodes: pathNodes || [],\n        path_relations: pathRelations || [],\n        path_score: pathScore || 1.0,\n        path_length: pathLength || 1,\n        start_entity: Array.isArray(row) ? row[0] : row.start_entity\n      };\n    });\n  }\n} catch (e) { \n  console.log('Graph parse error:', e.message); \n}\n\n// Vector Results (Pinecone)\ntry {\n  const pineconeData = (() => {\n  try { return $node['WF3: Pinecone HyDE Search'].json; }\n  catch(e) { return { matches: [] }; }\n})();\n  const matches = pineconeData.body?.matches || pineconeData.matches || [];\n  vectorResults = matches.map((m, idx) => ({\n    source: 'VECTOR',\n    id: m.id || `vector-${idx}`,\n    content: m.metadata?.text || m.metadata?.content || '',\n    score: m.score || 0,\n    metadata: m.metadata\n  }));\n} catch (e) { \n  console.log('Vector parse error:', e.message); \n}\n\n// Community Summaries\ntry {\n  const communityData = $node['Community Summaries Fetch'].json;\n  const commArray = Array.isArray(communityData) ? communityData : \n                    (communityData ? [communityData] : []);\n  communityResults = commArray\n    .filter(c => c && c.summary)\n    .map((c, idx) => ({\n      source: 'COMMUNITY',\n      id: c.community_id || `comm-${idx}`,\n      content: c.summary || '',\n      title: c.title,\n      entity_count: c.entity_count\n    }));\n} catch (e) { \n  console.log('Community parse error:', e.message); \n}\n\n// === HELPER: Format graph path for reading ===\nfunction formatGraphPath(nodes, relations) {\n  if (!nodes || nodes.length === 0) return '';\n  \n  let pathStr = nodes[0]?.name || (typeof nodes[0] === 'string' ? nodes[0] : 'Unknown');\n  \n  for (let i = 0; i < (relations?.length || 0) && i < nodes.length - 1; i++) {\n    const nextNode = nodes[i + 1]?.name || (typeof nodes[i + 1] === 'string' ? nodes[i + 1] : 'Unknown');\n    pathStr += ` --[${relations[i]}]--> ${nextNode}`;\n  }\n  return pathStr;\n}\n\n// === DEDUPLICATION & SCORING ===\nconst allResults = [...graphResults, ...vectorResults, ...communityResults];\n\nconst maxGraphScore = Math.max(...graphResults.map(r => r.path_score || 0), 1);\nconst maxVectorScore = Math.max(...vectorResults.map(r => r.score || 0), 1);\n\nconst normalizedResults = allResults.map(r => {\n  let normalizedScore = 0;\n  if (r.source === 'GRAPH') {\n    normalizedScore = (r.path_score / maxGraphScore) * (1 / (r.path_length * 0.3 + 0.7));\n  } else if (r.source === 'VECTOR') {\n    normalizedScore = r.score / maxVectorScore;\n  } else {\n    normalizedScore = 0.5;\n  }\n  return { ...r, normalized_score: normalizedScore };\n});\n\nnormalizedResults.sort((a, b) => b.normalized_score - a.normalized_score);\n\nconst finalResults = [];\nconst sourceCounts = { GRAPH: 0, VECTOR: 0, COMMUNITY: 0 };\nconst MAX_PER_SOURCE = 15;\nconst TOTAL_MAX = 30;\n\nfor (const result of normalizedResults) {\n  if (finalResults.length >= TOTAL_MAX) break;\n  if (sourceCounts[result.source] < MAX_PER_SOURCE) {\n    finalResults.push(result);\n    sourceCounts[result.source]++;\n  }\n}\n\n// === OUTPUT ===\nreturn [{\n  json: {\n    merged_results: finalResults,\n    source_counts: sourceCounts,\n    total_count: finalResults.length,\n    traversal_depth_used: Math.max(...graphResults.map(r => r.path_length || 0), 0),\n    hyde_document: (() => {\n      try {\n        const parsed = JSON.parse($node['WF3: HyDE & Entity Extraction'].json.choices[0].message.content || '{}');\n        return parsed.hyde_document || '';\n      } catch(e) {\n        // LLM returned plain text, not JSON - use the raw text as HyDE document\n        return $node['WF3: HyDE & Entity Extraction'].json.choices?.[0]?.message?.content || $node['OTEL Init'].json.query || '';\n      }\n    })()\n  }\n}];"
        },
        "id": "bc35ece7-e92d-4106-9c9f-05518d0da52e",
        "name": "Merge Graph + Vector + Community (Deep)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1200,
          6320
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $vars.RERANKER_API_URL || 'https://api.cohere.ai/v1/rerank' }}",
          "authentication": "none",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"model\": \"{{ $vars.RERANKER_MODEL || 'rerank-multilingual-v3.0' }}\",\n  \"query\": \"{{ $node['OTEL Init'].json.query }}\",\n  \"documents\": {{ JSON.stringify(($json.merged_results || []).map(d => d.content || '').filter(c => c.length > 0).slice(0, 25)) }},\n  \"top_n\": 10\n}",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 1,
                "batchInterval": 3000
              }
            },
            "timeout": 15000
          },
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "=Bearer {{ $vars.COHERE_API_KEY }}"
              }
            ]
          }
        },
        "id": "607cef8e-6604-49a2-bf00-2bbc64fbd6d4",
        "name": "WF3: Cohere Reranker",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          1376,
          6320
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Reranker fallback handler - CORRIGÃ‰\nconst rerankedResults = $json.results || [];\nconst mergeData = $node['Merge Graph + Vector + Community (Deep)'].json;\n\nreturn [{\n  json: {\n    reranked_results: rerankedResults,\n    merged_results: mergeData.merged_results || [],\n    source_counts: mergeData.source_counts || {},\n    traversal_depth: mergeData.traversal_depth_used || 0,\n    fallback: rerankedResults.length === 0\n  }\n}];"
        },
        "id": "7a948764-76a8-4062-a66c-55db8e797232",
        "name": "Reranker Fallback Handler",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1584,
          6304
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// PATCH 3.4: Token Budgeting & Map-Reduce for Large Contexts - CORRIGÃ‰\nconst MAX_TOKENS = 6000;\nconst CHARS_PER_TOKEN = 4;\n\nconst mergedResults = $json.merged_results || [];\nconst rerankedResults = $json.reranked_results || [];\n\nlet budget = MAX_TOKENS;\nconst allocated = { \n  reranked: [], \n  graph: [], \n  vector: [], \n  community: [] \n};\n\n// Allocate reranked first (highest priority)\nfor (const item of rerankedResults.slice(0, 5)) {\n  const content = typeof item === 'string' ? item : (item.document || item.content || '');\n  const tokens = Math.ceil(content.length / CHARS_PER_TOKEN);\n  if (budget >= tokens) {\n    allocated.reranked.push(item);\n    budget -= tokens;\n  }\n}\n\n// Allocate remaining results by source\nfor (const result of mergedResults) {\n  const tokens = Math.ceil((result.content?.length || 0) / CHARS_PER_TOKEN);\n  if (budget < tokens) continue;\n  \n  if (result.source === 'GRAPH' && allocated.graph.length < 10) {\n    allocated.graph.push(result);\n    budget -= tokens;\n  } else if (result.source === 'VECTOR' && allocated.vector.length < 10) {\n    allocated.vector.push(result);\n    budget -= tokens;\n  } else if (result.source === 'COMMUNITY' && allocated.community.length < 5) {\n    allocated.community.push(result);\n    budget -= tokens;\n  }\n}\n\n// Build compact relationship string from graph results\nconst relationships = allocated.graph\n  .filter(g => g.path_relations && g.path_nodes)\n  .map(g => {\n    const nodes = g.path_nodes || [];\n    const rels = g.path_relations || [];\n    if (nodes.length < 2) return null;\n    return `${nodes[0]?.name || 'Unknown'}-[${rels[0] || '?'}]->${nodes[1]?.name || 'Unknown'}`;\n  })\n  .filter(r => r !== null)\n  .slice(0, 20)\n  .join('; ');\n\nreturn [{\n  json: {\n    budgeted_context: {\n      reranked: allocated.reranked,\n      graph: allocated.graph,\n      vector: allocated.vector,\n      community: allocated.community,\n      relationships: relationships\n    },\n    tokens_used: MAX_TOKENS - budget,\n    tokens_remaining: budget,\n    fallback: $json.fallback || false,\n    traversal_depth: $json.traversal_depth || 0\n  }\n}];"
        },
        "id": "31aa61de-dd88-4c0b-884a-32f85142b63e",
        "name": "JS: Token Budgeting & Map-Reduce",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1760,
          6304
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Response Formatter - builds LLM Answer Synthesis request body\n// Handles missing vector results when embedding credits are exhausted\n\n// Safely get reranked vector results\nlet vectorResults = [];\ntry {\n  vectorResults = $node['WF3: Cohere Reranker']?.json?.results || [];\n} catch(e) {\n  vectorResults = [];\n}\n\n// Safely get Neo4j data\nlet neo4jData = null;\ntry {\n  neo4jData = $node['Validate Neo4j Results']?.json;\n} catch(e) {}\n\n// Safely get community data\nlet communityData = null;\ntry {\n  communityData = $node['Community Summaries Fetch']?.json;\n} catch(e) {}\n\n// Safely get entity extraction data\nlet entityData = null;\ntry {\n  entityData = $node['WF3: HyDE & Entity Extraction']?.json;\n} catch(e) {}\n\n// Build context from all available sources\nconst ctx = $json.budgeted_context || {};\nconst query = $node['OTEL Init'].json.query;\nconst traceId = $node['OTEL Init'].json.trace_id || '';\nconst contextParts = [];\n\n// Graph relationships from budgeted context\nif (ctx.relationships) {\n  contextParts.push('Graph Relationships: ' + ctx.relationships);\n}\nif (ctx.graph && ctx.graph.length > 0) {\n  const graphText = ctx.graph.slice(0, 5).map(g => g.content || g.text || '').filter(Boolean).join('\\n');\n  if (graphText) contextParts.push('Graph Context:\\n' + graphText);\n}\n\n// Vector/reranked docs\nif (ctx.reranked && ctx.reranked.length > 0) {\n  const rerankedText = ctx.reranked.slice(0, 5).map((d, i) => {\n    const content = typeof d === 'string' ? d : (d.document || d.content || d.text || '');\n    return '[Doc ' + (i+1) + '] ' + content;\n  }).filter(Boolean).join('\\n');\n  if (rerankedText) contextParts.push('Relevant Documents:\\n' + rerankedText);\n}\n\n// Community summaries\nif (ctx.community && ctx.community.length > 0) {\n  const commText = ctx.community.slice(0, 3).map(c => c.content || c.text || '').filter(Boolean).join('\\n');\n  if (commText) contextParts.push('Community Summaries:\\n' + commText);\n}\n\n// Fallback: if no budgeted context, try raw Neo4j data\nif (contextParts.length === 0) {\n  if (neo4jData && !neo4jData.skip_graph) {\n    // Extract paths from Neo4j v2 format\n    const values = neo4jData.data?.values || neo4jData.results?.[0]?.data?.map(d => d.row) || [];\n    if (values.length > 0) {\n      const pathStr = values.slice(0, 10).map(row => {\n        if (Array.isArray(row)) {\n          const startEntity = row[0];\n          const pathNodes = row[1] || [];\n          const pathRels = row[2] || [];\n          const nodeNames = Array.isArray(pathNodes) ? pathNodes.map(n => n.name || n).join(' -> ') : String(pathNodes);\n          return startEntity + ': ' + nodeNames + ' [' + (Array.isArray(pathRels) ? pathRels.join(', ') : '') + ']';\n        }\n        return JSON.stringify(row).substring(0, 200);\n      }).join('\\n');\n      contextParts.push('Entity Graph Paths:\\n' + pathStr);\n    }\n  }\n  \n  // Try community summaries raw data\n  if (communityData) {\n    const summaries = communityData.summaries || communityData;\n    if (Array.isArray(summaries) && summaries.length > 0) {\n      const commStr = summaries.slice(0, 3).map(s => s.summary || s.content || JSON.stringify(s).substring(0, 300)).join('\\n');\n      contextParts.push('Community Summaries:\\n' + commStr);\n    }\n  }\n  \n  // Try Hyde document as last resort context\n  if (contextParts.length === 0 && entityData) {\n    const content = entityData.choices?.[0]?.message?.content || '';\n    try {\n      const parsed = JSON.parse(content);\n      if (parsed.hyde_document) {\n        contextParts.push('Background Knowledge:\\n' + parsed.hyde_document);\n      }\n    } catch(e) {\n      if (content.length > 20) {\n        contextParts.push('Background Knowledge:\\n' + content.substring(0, 1000));\n      }\n    }\n  }\n}\n\nconst fullContext = contextParts.join('\\n\\n');\nconst embedding_fallback = vectorResults.length === 0;\nconst traversal_depth = ctx.graph?.length || 0;\nconst context_sources = contextParts.length;\n\n// Build request body for LLM Answer Synthesis\nconst requestBody = {\n  model: 'arcee-ai/trinity-large-preview:free',\n  messages: [\n    {\n      role: 'system',\n      content: 'You are a precise knowledge graph assistant. Answer questions using ONLY the provided context. For factual questions (who/what/where/when), answer in 1-5 words. For yes/no questions, start with Yes or No. For numerical questions, give the number with unit. NEVER say you lack information - always provide your best answer from the context. Respond in the SAME LANGUAGE as the question.'\n    },\n    {\n      role: 'user',\n      content: 'Context:\\n' + fullContext + '\\n\\nQuestion: ' + query + '\\n\\nAnswer concisely:'\n    }\n  ],\n  temperature: 0.1,\n  max_tokens: 300\n};\n\nreturn [{\n  json: {\n    requestBody: requestBody,\n    trace_id: traceId,\n    embedding_fallback: embedding_fallback,\n    tokens_used: 0,\n    traversal_depth: traversal_depth,\n    context_sources: context_sources,\n    debug_context_length: fullContext.length,\n    debug_context_parts: contextParts.length\n  }\n}];"
        },
        "id": "0520b590-2736-4e0e-9191-0cb6ac9cce39",
        "name": "Response Formatter",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1968,
          6304
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $vars.OTEL_COLLECTOR_URL || 'https://otel-collector.internal' }}/v1/traces",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"traceId\": \"={{ $json.trace_id }}\",\n  \"spanName\": \"graph_rag_complete\",\n  \"status\": \"={{ $json.status }}\"\n}",
          "options": {
            "timeout": 5000
          }
        },
        "id": "5767bffd-b95a-4837-ae02-871f103c9944",
        "name": "Shield #9: Export Trace",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          2160,
          6304
        ],
        "disabled": true,
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "content": "# ðŸ”§ VARIABLES D'ENVIRONNEMENT (SOTA 2026) - CORRECTED V3.3.1\n\n## CORRECTIONS APPLIQUÃ‰ES:\n1. âœ… OTEL Init: Fixed duplicate 'const query' declaration\n2. âœ… WF3: Cohere Reranker: Fixed triple nested template\n3. âœ… Model references updated for OpenRouter format\n\n## LLM APIs\n- `OPENROUTER_BASE_URL` - https://openrouter.ai/api/v1/chat/completions\n- `LLM_HYDE_MODEL` - google/gemini-2.0-flash-exp\n\n## Databases\n- `NEO4J_URL` - Neo4j HTTP API URL\n- `PINECONE_URL` - Pinecone query endpoint\n\n## Reranking\n- `RERANKER_API_URL` - https://api.cohere.ai/v1/rerank\n- `RERANKER_MODEL` - rerank-multilingual-v3.0\n",
          "height": 500,
          "width": 400
        },
        "id": "06eeed8a-47ad-49e4-94be-59effdb952c8",
        "name": "ðŸ“‹ Configuration SOTA 2026",
        "type": "n8n-nodes-base.stickyNote",
        "typeVersion": 1,
        "position": [
          -544,
          6176
        ]
      },
      {
        "parameters": {
          "inputSource": "passthrough"
        },
        "type": "n8n-nodes-base.executeWorkflowTrigger",
        "typeVersion": 1.1,
        "position": [
          -80,
          6416
        ],
        "id": "fb3ea9ac-ff4c-411c-8ea0-ed74b27af584",
        "name": "When Executed by Another Workflow"
      },
      {
        "parameters": {
          "public": true,
          "availableInChat": true,
          "options": {}
        },
        "type": "@n8n/n8n-nodes-langchain.chatTrigger",
        "typeVersion": 1.4,
        "position": [
          -48,
          6608
        ],
        "id": "0735714d-f746-45d8-add1-bdcd8eee651f",
        "name": "When chat message received",
        "webhookId": "d4017c54-b97c-44ea-b3e8-856b500eb665"
      },
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "ff622742-6d71-4e91-af71-b5c666088717",
          "responseMode": "responseNode",
          "options": {}
        },
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2.1,
        "position": [
          -96,
          6240
        ],
        "id": "d8c31157-76d1-4bb1-90be-671b77740e9e",
        "name": "Webhook",
        "webhookId": "ff622742-6d71-4e91-af71-b5c666088717"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $vars.EMBEDDING_API_URL || 'https://api.cohere.com/v2/embed' }}",
          "authentication": "none",
          "nodeCredentialType": "openRouterApi",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { \"model\": ($vars.EMBEDDING_MODEL || 'embed-english-v3.0'), \"texts\": [$json.hyde_document], \"input_type\": \"search_query\", \"embedding_types\": [\"float\"] } }}",
          "options": {
            "retry": {
              "maxTries": 3,
              "waitBetweenTries": 2000
            }
          },
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "=Bearer {{ $vars.COHERE_API_KEY }}"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          496,
          6688
        ],
        "id": "aae84d9a-da5e-4949-a6ed-9e696d260f95",
        "name": "Generate HyDE Embedding",
        "credentials": {},
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Extract HyDE Document - handles both JSON and plain text responses\nlet hydeDocument = '';\nconst rawContent = $json.choices?.[0]?.message?.content || '';\n\n// Strategy 1: Try JSON parse (model may output structured JSON)\ntry {\n  const parsed = JSON.parse(rawContent);\n  hydeDocument = parsed.hyde_document || '';\n} catch (e) {\n  // Strategy 2: Try to find JSON embedded in text\n  const jsonMatch = rawContent.match(/\\{[\\s\\S]*\"hyde_document\"[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    try {\n      const embedded = JSON.parse(jsonMatch[0]);\n      hydeDocument = embedded.hyde_document || '';\n    } catch (e2) {}\n  }\n}\n\n// Strategy 3: Use raw text as HyDE document (it IS a good hypothetical doc)\nif (!hydeDocument || hydeDocument.length < 10) {\n  hydeDocument = rawContent.replace(/```json[\\s\\S]*?```/g, '').trim();\n}\n\n// Final fallback to original query\nif (!hydeDocument || hydeDocument.length < 10) {\n  hydeDocument = $node['OTEL Init'].json.query;\n}\n\nreturn [{\n  json: {\n    hyde_document: hydeDocument,\n    original_query: $node['OTEL Init'].json.query,\n    hyde_success: hydeDocument !== $node['OTEL Init'].json.query && hydeDocument.length > 50\n  }\n}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          320,
          6688
        ],
        "id": "151d0ab0-4d4c-4d59-b7e1-833f025720be",
        "name": "Extract HyDE Document",
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Validate Neo4j Results - handles both REST and query/v2 API formats\nconst neo4jData = $json;\n\nlet hasResults = false;\nlet errorMessage = null;\n\n// Check for errors\nif (neo4jData.errors && neo4jData.errors.length > 0) {\n  errorMessage = neo4jData.errors[0].message;\n}\n\n// Check for results in different formats\n// Format 1: REST API (results[0].data)\nif (neo4jData.results?.[0]?.data?.length > 0) {\n  hasResults = true;\n}\n// Format 2: Query v2 API (data.values)\nif (neo4jData.data?.values?.length > 0) {\n  hasResults = true;\n}\n// Format 3: body wrapper\nif (neo4jData.body?.results?.[0]?.data?.length > 0) {\n  hasResults = true;\n}\nif (neo4jData.body?.data?.values?.length > 0) {\n  hasResults = true;\n}\n\nif (!hasResults) {\n  return [{\n    json: {\n      skip_graph: true,\n      error: errorMessage,\n      results: { results: [{ data: [] }] }\n    }\n  }];\n}\n\nreturn [{ json: neo4jData }];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          864,
          5968
        ],
        "id": "a556d066-841a-4dbb-9c8b-fb78c7e0d224",
        "name": "Validate Neo4j Results",
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "const embeddingData = $json;\n\n// Check if we have a valid embedding - handle both Cohere and OpenRouter formats\nlet embedding = [];\n\n// Cohere v2 format: embeddings.float[0]\nif (embeddingData.embeddings?.float?.[0]) {\n  embedding = embeddingData.embeddings.float[0];\n}\n// OpenRouter/OpenAI format: data[0].embedding\nelse if (embeddingData.data?.[0]?.embedding) {\n  embedding = embeddingData.data[0].embedding;\n}\n// Body wrapper variants\nelse if (embeddingData.body?.embeddings?.float?.[0]) {\n  embedding = embeddingData.body.embeddings.float[0];\n}\nelse if (embeddingData.body?.data?.[0]?.embedding) {\n  embedding = embeddingData.body.data[0].embedding;\n}\nelse if (Array.isArray(embeddingData.embedding)) {\n  embedding = embeddingData.embedding;\n}\n\n// Validate embedding dimensions (1024 for Cohere, 1536 for OpenAI)\nconst expectedDims = parseInt($vars.EMBEDDING_DIMS || '1024');\nconst isValid = embedding.length >= 384; // Accept any reasonable dimension\n\nif (!isValid) {\n  return [{\n    json: {\n      valid: false,\n      error: `Invalid embedding: got ${embedding.length}, expected ${expectedDims}`,\n      embedding: [],\n      fallback: true\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    valid: true,\n    embedding: embedding,\n    dimensions: embedding.length\n  }\n}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          720,
          6688
        ],
        "id": "46cf3f08-8e8f-4722-84e4-719684a5ea2b",
        "name": "Validate Embedding",
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "mode": "combine",
          "combineBy": "combineAll",
          "options": {}
        },
        "type": "n8n-nodes-base.merge",
        "typeVersion": 3.2,
        "position": [
          960,
          6432
        ],
        "id": "08524ce1-8a7e-4ce4-a9bb-4745270a4c2c",
        "name": "Merge",
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $vars.OPENROUTER_BASE_URL || 'https://openrouter.ai/api/v1/chat/completions' }}",
          "authentication": "none",
          "nodeCredentialType": "openRouterApi",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
          "options": {
            "timeout": 30000,
            "retry": {
              "maxTries": 1,
              "waitBetweenTries": 5000
            }
          },
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "=Bearer {{ $vars.OPENROUTER_API_KEY }}"
              }
            ]
          }
        },
        "id": "a1b2c3d4-llm-answer-synthesis",
        "name": "LLM Answer Synthesis",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          2080,
          6304
        ],
        "credentials": {},
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Extract LLM answer and format final response\n// Handle rate limit errors gracefully\nconst llmResponse = $json;\nlet answer = '';\n\nif (llmResponse.error) {\n  // LLM call failed - try to extract partial info from context\n  const ctx = $node['Response Formatter']?.json || {};\n  // Try to extract answer from context even if LLM failed\n    const ctxFallback = $node['Response Formatter']?.json || {};\n    const contextText = ctxFallback.context || '';\n    if (contextText.length > 20) {\n      // Use first meaningful sentence from context as answer\n      const sentences = contextText.split(/[.!?]/).filter(s => s.trim().length > 10);\n      answer = sentences.slice(0, 2).join('. ').trim() + '.';\n    } else {\n      answer = 'Information not available in the knowledge graph.';\n    }\n} else {\n  answer = llmResponse.choices?.[0]?.message?.content || '';\n}\n\nif (!answer || answer.trim() === '') {\n  answer = 'No answer generated';\n}\n\nconst contextData = $node['Response Formatter']?.json || {};\n\nreturn [{ json: {\n  status: answer !== 'No answer generated' ? 'SUCCESS' : 'NO_ANSWER',\n  trace_id: contextData.trace_id || '',\n  response: answer.trim(),\n  metadata: {\n    source: 'graph_rag_llm_synthesis',\n    tokens_used: contextData.tokens_used || 0,\n    traversal_depth: contextData.traversal_depth || 0,\n    context_sources: contextData.context_sources || 0\n  }\n} }];"
        },
        "id": "e5f6g7h8-answer-formatter",
        "name": "Answer Formatter",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2280,
          6304
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify($json) }}",
          "options": {}
        },
        "id": "r1s2t3u4-respond-webhook",
        "name": "Respond to Webhook",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.1,
        "position": [
          2480,
          6304
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// GitHub Error Logger for graph\nconst errorData = $input.first().json;\nconst timestamp = new Date().toISOString();\nconst questionId = errorData.question_id || errorData.trace_id || 'q-' + Date.now();\nconst errorType = errorData.error_type || errorData.error_code || 'UNKNOWN';\nconst pipeline = 'graph';\n\nconst logEntry = {\n  timestamp: timestamp,\n  pipeline: pipeline,\n  question_id: questionId,\n  error_type: errorType,\n  error_message: (errorData.error || errorData.message || 'No message').slice(0, 500),\n  input: {\n    query: (errorData.query || errorData.original_query || '').slice(0, 300),\n    tenant_id: errorData.tenant_id || 'benchmark'\n  },\n  partial_response: errorData.partial_response || errorData.response || null,\n  n8n_context: {\n    workflow_id: $workflow.id,\n    workflow_name: $workflow.name,\n    execution_id: $execution.id\n  },\n  performance: {\n    latency_ms: errorData.latency_ms || 0,\n    http_status: errorData.http_status || null\n  }\n};\n\nreturn [{ json: logEntry }];"
        },
        "id": "ab13bde8-d072-4213-82eb-019c383cf22a",
        "name": "GitHub Error Logger (graph)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2780,
          0
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Entity Extraction Logger\nconst input = $input.first().json;\nconst entities = input.entities || input.parameters?.entity_names || [];\nconst skipNeo4j = input.skip_neo4j || false;\n\nconst log = {\n  timestamp: new Date().toISOString(),\n  pipeline: 'graph',\n  step: 'entity_extraction',\n  query: (input.query_text || input.query || '').slice(0, 300),\n  entities_extracted: entities,\n  entity_count: entities.length,\n  skip_neo4j: skipNeo4j,\n  hyde_preview: (input.hyde_document || '').slice(0, 200)\n};\n\n// Pass through original data + log\nreturn [{ json: { ...input, _entity_log: log } }];"
        },
        "id": "670719ff-3e44-4f90-bb2b-78bd7d447a8d",
        "name": "Entity Extraction Logger",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2780,
          200
        ],
        "onError": "continueRegularOutput"
      }
    ],
    "connections": {
      "OTEL Init": {
        "main": [
          [
            {
              "node": "WF3: HyDE & Entity Extraction",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "WF3: HyDE & Entity Extraction": {
        "main": [
          [
            {
              "node": "Extract HyDE Document",
              "type": "main",
              "index": 0
            },
            {
              "node": "Neo4j Query Builder (Deep Traversal V2)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Neo4j Query Builder (Deep Traversal V2)": {
        "main": [
          [
            {
              "node": "Shield #4: Neo4j Guardian Traversal",
              "type": "main",
              "index": 0
            },
            {
              "node": "Community Summaries Fetch",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Shield #4: Neo4j Guardian Traversal": {
        "main": [
          [
            {
              "node": "Validate Neo4j Results",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "WF3: Pinecone HyDE Search": {
        "main": [
          [
            {
              "node": "Merge",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Community Summaries Fetch": {
        "main": [
          [
            {
              "node": "Merge",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Graph + Vector + Community (Deep)": {
        "main": [
          [
            {
              "node": "WF3: Cohere Reranker",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "WF3: Cohere Reranker": {
        "main": [
          [
            {
              "node": "Reranker Fallback Handler",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Reranker Fallback Handler",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Reranker Fallback Handler": {
        "main": [
          [
            {
              "node": "JS: Token Budgeting & Map-Reduce",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "JS: Token Budgeting & Map-Reduce": {
        "main": [
          [
            {
              "node": "Response Formatter",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Response Formatter": {
        "main": [
          [
            {
              "node": "LLM Answer Synthesis",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "When Executed by Another Workflow": {
        "main": [
          [
            {
              "node": "OTEL Init",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "When chat message received": {
        "main": [
          [
            {
              "node": "OTEL Init",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Webhook": {
        "main": [
          [
            {
              "node": "OTEL Init",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate HyDE Embedding": {
        "main": [
          [
            {
              "node": "Validate Embedding",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract HyDE Document": {
        "main": [
          [
            {
              "node": "Generate HyDE Embedding",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate Neo4j Results": {
        "main": [
          [
            {
              "node": "Merge",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate Embedding": {
        "main": [
          [
            {
              "node": "WF3: Pinecone HyDE Search",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge": {
        "main": [
          [
            {
              "node": "Merge Graph + Vector + Community (Deep)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "LLM Answer Synthesis": {
        "main": [
          [
            {
              "node": "Answer Formatter",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Answer Formatter": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            },
            {
              "node": "Shield #9: Export Trace",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "GitHub Error Logger (graph)": {
        "main": [
          [
            {
              "node": "GitHub Error Logger (graph)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Alexis Moret",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-10T12:08:30.711Z",
        "id": 859,
        "workflowId": "95x2BBAbJlLWZtWEJn6rb",
        "versionId": "377c8f45-db4d-405f-a096-b7d25fd0c7ce",
        "event": "activated",
        "userId": "215767e0-958a-4c74-a67a-e335807eba64"
      }
    ]
  }
}
{
  "name": "TEST - SOTA 2026 - WF4 Quantitative V2.0",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// ============================================\n// PATCH #1: INIT & ACL - ORCHESTRATOR SUPPORT\n// ============================================\n// Pour: WF4 Quantitative & WF2 Graph\n// Bug: Workflows \u00e9chouent quand appel\u00e9s par orchestrateur\n// Fix: Support multi-format d'entr\u00e9e\n\n// Init & ACL for RAG - HARDENED V2.2 (ORCHESTRATOR FIX)\nconst rawInput = $input.first().json;\nconst input = rawInput.body || rawInput;\n\n// === EXTRACTION ROBUSTE DE LA QUERY ===\n// Supporte: webhook, chat trigger, sub-workflow, ET orchestrator\nlet queryStr = '';\n\n// Priorit\u00e9 1: Direct query field (webhook/chat)\nif (typeof input.query === 'string') {\n  queryStr = input.query;\n}\n// Priorit\u00e9 2: Chat input\nelse if (input.chatInput) {\n  queryStr = input.chatInput;\n}\n// Priorit\u00e9 3: Orchestrator format - task_query\nelse if (input.task_query) {\n  queryStr = input.task_query;\n}\n// Priorit\u00e9 4: Orchestrator format - current_task.query\nelse if (input.current_task && typeof input.current_task.query === 'string') {\n  queryStr = input.current_task.query;\n}\n// Priorit\u00e9 5: Query as object (stringify)\nelse if (input.query && typeof input.query === 'object') {\n  queryStr = JSON.stringify(input.query);\n}\n\nconst query = queryStr.trim();\n\n// === VALIDATION ===\nif (!query || query.length < 2) {\n  throw new Error('VALIDATION_ERROR: query is required and must be at least 2 characters');\n}\n\n// === EXTRACTION DU USER CONTEXT ===\n// Parse user_context (peut \u00eatre string JSON ou objet)\nlet userContext = {};\n\nif (typeof input.user_context === 'string') {\n  try {\n    userContext = JSON.parse(input.user_context);\n  } catch (e) {\n    userContext = {};\n  }\n} else if (input.user_context && typeof input.user_context === 'object') {\n  userContext = input.user_context;\n}\n\n// === EXTRACTION DU TRACE_ID ===\n// Support multiple sources\nconst traceId = input.trace_id || \n                input.current_task?.trace_id || \n                `tr-rag-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;\n\n// === OUTPUT ===\nreturn [{\n  json: {\n    trace_id: traceId,\n    query: query.substring(0, 2000),\n    user_context: {\n      tenant_id: userContext.tenant_id || input.tenant_id || 'default',\n      groups: Array.isArray(userContext.groups) ? userContext.groups : ['guest']\n    },\n    timestamp: new Date().toISOString(),\n    source: rawInput.body ? 'webhook' : \n            (rawInput.chatInput ? 'chat' : \n            (input.task_query ? 'orchestrator' : 'subworkflow')),\n    \n    // Metadata pour debugging\n    _debug: {\n      original_input_keys: Object.keys(input),\n      query_source: input.task_query ? 'task_query' : \n                    (input.current_task ? 'current_task.query' : \n                    (input.chatInput ? 'chatInput' : 'query'))\n    }\n  }\n}];\n\n"
      },
      "id": "d8623e2a-1060-46e1-b3e9-33251065d013",
      "name": "Init & ACL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        208
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT table_name, column_name, data_type, is_nullable \nFROM information_schema.columns \nWHERE table_schema = 'public'\n  AND table_name NOT LIKE 'pg_%'\n  AND table_name NOT LIKE '_realtime%'\n  AND table_name NOT LIKE 'supabase_%'\nORDER BY table_name, ordinal_position\nLIMIT 500",
        "options": {}
      },
      "id": "629ec593-2bf6-4688-99d2-fe8b2009e062",
      "name": "Schema Introspection",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        400,
        208
      ],
      "credentials": {
        "postgres": {
          "id": "zEr7jPswZNv6lWKu",
          "name": "Supabase PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build schema context for LLM \u2014 ENRICHED with sample values\nconst inputData = $input.all();\nif (!inputData || inputData.length === 0) {\n  return {\n    ...$node['Init & ACL'].json,\n    schema_context: \"Aucune table trouv\u00e9e dans le sch\u00e9ma public.\",\n    available_tables: []\n  };\n}\n\nconst schemaData = inputData.map(i => i.json);\nconst tables = {};\n\nschemaData.forEach(col => {\n  if (!tables[col.table_name]) tables[col.table_name] = [];\n  tables[col.table_name].push(`${col.column_name} ${col.data_type}${col.is_nullable === 'NO' ? ' NOT NULL' : ''}`);\n});\n\n// Sample values for key lookup columns to help LLM generate exact matches\nconst sampleValues = {\n  financials: {\n    company_name: [\"TechVision Inc\", \"GreenEnergy Corp\", \"HealthPlus Labs\"],\n    company_id: [\"techvision\", \"greenenergy\", \"healthplus\"],\n    period: [\"FY\", \"Q1\", \"Q2\", \"Q3\", \"Q4\"],\n    fiscal_year: [2020, 2021, 2022, 2023],\n    _IMPORTANT_NOTE: \"The financials table has BOTH full-year rows (period=FY) and quarterly rows (period=Q1..Q4). For annual totals use WHERE period='FY'. For quarterly data filter on specific quarter. NEVER sum across all periods without filtering \u2014 that double-counts FY + quarters.\"\n  },\n  balance_sheet: {\n    company_name: [\"TechVision Inc\", \"GreenEnergy Corp\", \"HealthPlus Labs\"],\n    company_id: [\"techvision\", \"greenenergy\", \"healthplus\"],\n    fiscal_year: [2020, 2021, 2022, 2023]\n  },\n  sales_data: {\n    company_id: [\"techvision\", \"greenenergy\", \"healthplus\"],\n    category: [\"Cloud Services\", \"AI/ML\", \"Security\", \"Data Analytics\", \"Solar Panels\", \"Wind Turbines\", \"Battery Storage\", \"Energy Management\", \"Diagnostics\", \"Therapeutics\", \"Digital Health\"],\n    region: [\"North America\", \"Europe\", \"Asia Pacific\", \"Latin America\", \"Middle East\"],\n    quarter: [\"Q1\", \"Q2\", \"Q3\", \"Q4\"],\n    fiscal_year: [2020, 2021, 2022, 2023]\n  },\n  employees: {\n    company_id: [\"techvision\", \"greenenergy\", \"healthplus\"],\n    department: [\"Engineering\", \"Sales\", \"Marketing\", \"Finance\", \"Operations\", \"HR\", \"Product\", \"Research\"],\n    region: [\"North America\", \"Europe\", \"Asia Pacific\", \"Latin America\"],\n    status: [\"active\", \"inactive\"]\n  },\n  products: {\n    company_id: [\"techvision\", \"greenenergy\", \"healthplus\"],\n    category: [\"Cloud Services\", \"AI/ML\", \"Security\", \"Data Analytics\", \"Solar Panels\", \"Wind Turbines\", \"Battery Storage\", \"Energy Management\", \"Diagnostics\", \"Therapeutics\", \"Digital Health\"],\n    status: [\"active\"]\n  }\n};\n\nconst schemaContext = Object.entries(tables)\n  .map(([table, columns]) => {\n    let text = `Table: ${table}\\nColumns: ${columns.join(', ')}`;\n    if (sampleValues[table]) {\n      const samples = Object.entries(sampleValues[table])\n        .map(([col, vals]) => `  ${col}: ${JSON.stringify(vals)}`)\n        .join('\\n');\n      text += `\\nSample values (use EXACT values for filters):\\n${samples}`;\n    }\n    return text;\n  })\n  .join('\\n\\n');\n\nconst initData = $node['Init & ACL'].json;\n\nreturn {\n  ...initData,\n  schema_context: schemaContext,\n  available_tables: Object.keys(tables)\n};"
      },
      "id": "f52905d6-700c-45b2-8265-4501a7c08482",
      "name": "Schema Context Builder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        608,
        208
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.OPENROUTER_BASE_URL || 'https://openrouter.ai/api/v1/chat/completions' }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openRouterApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.requestBody) }}\n",
        "options": {
          "timeout": 25000
        }
      },
      "id": "1b0e89ee-a913-498e-ab6d-2f8d568a2d2f",
      "name": "Text-to-SQL Generator (CoT Enhanced)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        800,
        208
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "nTJdf91Z5vhsI7cm",
          "name": "Unstructured API"
        },
        "openRouterApi": {
          "id": "aTHBqnntMBApo0Dy",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// CRITICAL: SQL Validator - Security Shield (ERROR-SAFE VERSION)\n// Never throws - returns error data that flows through pipeline\nconst contextData = $node['Schema Context Builder'].json;\n\ntry {\n  let llmResponse = {};\n  try {\n    llmResponse = JSON.parse($json.choices?.[0]?.message?.content || '{}');\n  } catch (e) {\n    // LLM returned invalid JSON - return safe fallback\n    return {\n      ...contextData,\n      validated_sql: \"SELECT 'SQL_GENERATION_ERROR: Invalid LLM response' as error_message, 'error' as status WHERE tenant_id = '\" + contextData.user_context.tenant_id + \"' LIMIT 1\",\n      explanation: 'LLM returned invalid JSON response',\n      validation_status: 'FAILED',\n      validation_error: 'SQL_GENERATION_ERROR',\n      validation_timestamp: new Date().toISOString()\n    };\n  }\n\n  const sql = String(llmResponse.sql || '').trim();\n  const sqlUpper = sql.toUpperCase();\n\n  // FORBIDDEN PATTERNS - P0 Security\n  const forbiddenPatterns = [\n    /DELETE|UPDATE|INSERT|DROP|TRUNCATE|ALTER|CREATE/i,\n    /GRANT|REVOKE|EXEC|EXECUTE|CALL/i,\n    /--|;.*;|UNION.*SELECT/i,\n    /xp_|sp_|pg_sleep/i,\n    /\\bINTO\\s+OUTFILE\\b|\\bLOAD_FILE\\b/i\n  ];\n\n  for (const pattern of forbiddenPatterns) {\n    if (pattern.test(sqlUpper)) {\n      return {\n        ...contextData,\n        validated_sql: \"SELECT 'SQL_INJECTION_DETECTED' as error_message, 'error' as status WHERE tenant_id = '\" + contextData.user_context.tenant_id + \"' LIMIT 1\",\n        explanation: 'Forbidden SQL pattern detected',\n        validation_status: 'FAILED',\n        validation_error: 'SQL_INJECTION_DETECTED',\n        validation_timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  // REQUIRED PATTERNS - return error instead of throwing\n  if (!sqlUpper.startsWith('SELECT')) {\n    return {\n      ...contextData,\n      validated_sql: \"SELECT 'Query must start with SELECT' as error_message, 'error' as status WHERE tenant_id = '\" + contextData.user_context.tenant_id + \"' LIMIT 1\",\n      explanation: 'Query must start with SELECT',\n      validation_status: 'FAILED',\n      validation_error: 'SQL_VALIDATION_ERROR',\n      validation_timestamp: new Date().toISOString()\n    };\n  }\n\n  // Add LIMIT if missing (instead of throwing)\n  let finalSql = llmResponse.sql;\n  if (!sqlUpper.includes('LIMIT')) {\n    finalSql = finalSql + ' LIMIT 1000';\n  }\n\n  // Extract LIMIT value\n  const limitMatch = sqlUpper.match(/LIMIT\\s+(\\d+)/i);\n  if (limitMatch) {\n    const limitValue = parseInt(limitMatch[1]);\n    if (limitValue > 1000) {\n      finalSql = finalSql.replace(/LIMIT\\s+\\d+/i, 'LIMIT 1000');\n    }\n  }\n\n  // Check tenant_id filter - add if missing (instead of throwing)\n  if (!sqlUpper.includes('TENANT_ID')) {\n    // Try to add tenant_id filter\n    if (sqlUpper.includes('WHERE')) {\n      finalSql = finalSql.replace(/WHERE/i, `WHERE tenant_id = '${contextData.user_context.tenant_id}' AND`);\n    } else if (sqlUpper.includes('FROM')) {\n      finalSql = finalSql.replace(/(FROM\\s+\\w+)/i, `$1 WHERE tenant_id = '${contextData.user_context.tenant_id}'`);\n    }\n  }\n\n  // Passed validation\n  return {\n    ...contextData,\n    validated_sql: finalSql,\n    explanation: llmResponse.explanation || '',\n    validation_status: 'PASSED',\n    validation_timestamp: new Date().toISOString()\n  };\n\n} catch (globalError) {\n  // Catch-all: never let the node crash\n  return {\n    ...contextData,\n    validated_sql: \"SELECT 'VALIDATOR_ERROR: \" + String(globalError.message).replace(/'/g, \"''\").substring(0, 100) + \"' as error_message, 'error' as status LIMIT 1\",\n    explanation: 'Validator encountered an unexpected error: ' + globalError.message,\n    validation_status: 'FAILED',\n    validation_error: 'VALIDATOR_CRASH',\n    validation_timestamp: new Date().toISOString()\n  };\n}\n"
      },
      "id": "e3780345-617d-4483-9ab4-79a5c8873cf8",
      "name": "SQL Validator (Shield #1)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        208
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.validated_sql }}",
        "options": {}
      },
      "id": "9ca49b68-4d2e-4770-8118-1fc2c22b2ab9",
      "name": "SQL Executor (Postgres)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1216,
        208
      ],
      "credentials": {
        "postgres": {
          "id": "zEr7jPswZNv6lWKu",
          "name": "Supabase PostgreSQL"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for interpretation - handles both success and error from SQL Executor\nlet validatorData = {};\ntry {\n  validatorData = $node['SQL Validator (Shield #1)'].json || {};\n} catch (e) {\n  validatorData = {};\n}\n\nconst inputItems = $input.all();\nconst sqlResults = [];\n\nfor (const item of inputItems) {\n  // Check if this is an error item\n  if (item.json && !item.json.error && !item.json.errorMessage) {\n    sqlResults.push(item.json);\n  }\n}\n\nif (sqlResults.length === 0) {\n  return {\n    ...validatorData,\n    sql_results: [],\n    result_count: 0,\n    has_results: false\n  };\n}\n\nreturn {\n  ...validatorData,\n  sql_results: sqlResults,\n  result_count: sqlResults.length,\n  has_results: true,\n  result_preview: JSON.stringify(sqlResults.slice(0, 5), null, 2)\n};\n"
      },
      "id": "47637bf5-d3c9-4a67-9864-3b5a547ca262",
      "name": "Result Aggregator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1456,
        0
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.OPENROUTER_BASE_URL || 'https://openrouter.ai/api/v1/chat/completions' }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openRouterApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {
          "timeout": 25000
        }
      },
      "id": "1179b1b8-11c3-41ae-b750-cec4e2687620",
      "name": "Interpretation Layer (LLM Analyst)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1872,
        0
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "nTJdf91Z5vhsI7cm",
          "name": "Unstructured API"
        },
        "openRouterApi": {
          "id": "aTHBqnntMBApo0Dy",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Response Formatter - handles both success and error paths\n// FIXED: Detects null aggregation results and flags as DATA_NOT_FOUND\nlet aggregatorData = {};\nlet initData = {};\nlet interpretation = '';\n\ntry {\n  initData = $node['Init & ACL'].json || {};\n} catch (e) {\n  initData = {};\n}\n\ntry {\n  aggregatorData = $node['Result Aggregator'].json || {};\n} catch (e) {\n  aggregatorData = {};\n}\n\n// Determine interpretation based on input source\nif ($json.choices?.[0]?.message?.content) {\n  interpretation = $json.choices[0].message.content;\n} else if ($json.error || $json.fallback_message) {\n  interpretation = $json.fallback_message || 'Unable to generate SQL query for this question. Error: ' + ($json.error || 'unknown');\n} else {\n  interpretation = 'No interpretation available';\n}\n\n// === NEW: Detect null/empty aggregation results ===\nlet validationStatus = aggregatorData.validation_status || 'UNKNOWN';\nlet status = validationStatus === 'PASSED' ? 'SUCCESS' : 'ERROR';\n\nconst rawResults = aggregatorData.has_results ? (aggregatorData.sql_results || []) : [];\nconst sqlExecuted = (aggregatorData.validated_sql || '').toUpperCase();\n\n// Check if this was an aggregation query (SUM, AVG, COUNT, MIN, MAX) that returned null\nconst isAggregation = /\\b(SUM|AVG|COUNT|MIN|MAX)\\s*\\(/i.test(sqlExecuted);\nif (isAggregation && rawResults.length > 0) {\n  const allNulls = rawResults.every(row => {\n    return Object.values(row).every(v => v === null || v === undefined);\n  });\n  if (allNulls) {\n    status = 'DATA_NOT_FOUND';\n    validationStatus = 'NULL_RESULT';\n    interpretation = `[WARNING: Aggregation query returned NULL \u2014 this likely means no matching rows were found. ` +\n      `Check that entity names and filters match the exact values in the database.] ` + interpretation;\n  }\n}\n\n// Check for empty result set on non-aggregation queries\nif (!isAggregation && rawResults.length === 0 && validationStatus === 'PASSED') {\n  status = 'NO_DATA';\n  validationStatus = 'EMPTY_RESULT';\n}\n\nreturn {\n  status: status,\n  trace_id: aggregatorData.trace_id || initData.trace_id || '',\n  query: aggregatorData.query || initData.query || '',\n  sql_executed: aggregatorData.validated_sql || '',\n  result_count: aggregatorData.result_count || 0,\n  interpretation: interpretation,\n  raw_results: rawResults,\n  metadata: {\n    validation_status: validationStatus,\n    timestamp: new Date().toISOString(),\n    engine: 'QUANTITATIVE'\n  }\n};"
      },
      "id": "d059dfee-3534-4743-a6f8-bb29e0cf17be",
      "name": "Response Formatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2128,
        208
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.OTEL_COLLECTOR_URL || 'https://otel-collector.internal' }}/v1/traces",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"traceId\": \"{{ $json.trace_id }}\",\n  \"spanName\": \"quantitative_rag_complete\",\n  \"status\": \"{{ $json.status }}\",\n  \"attributes\": {\n    \"result_count\": {{ $json.result_count }},\n    \"sql_length\": {{ $json.sql_executed?.length || 0 }}\n  }\n}",
        "options": {
          "timeout": 5000
        }
      },
      "id": "5ba4b171-8e2a-4e2d-82ef-04d6f3cb5c01",
      "name": "OTEL Export (Shield #9)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2384,
        208
      ],
      "onError": "continueErrorOutput",
      "disabled": true
    },
    {
      "parameters": {},
      "id": "3abfc5c3-e8ce-40ab-936d-a49a33c8e47c",
      "name": "Error Handler",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [
        368,
        640
      ]
    },
    {
      "parameters": {
        "jsCode": "// Error handler for SQL validation/execution errors\nconst error = $json;\nconst initData = $node['Init & ACL']?.json || {};\n\nreturn {\n  status: 'ERROR',\n  trace_id: initData.trace_id,\n  error_type: error.message?.includes('SQL_') ? 'SQL_ERROR' : 'SYSTEM_ERROR',\n  error_message: error.message || 'Unknown error',\n  timestamp: new Date().toISOString()\n};"
      },
      "id": "84eb686e-dc41-452e-a894-f0b6603457c1",
      "name": "Error Response Builder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        576,
        640
      ]
    },
    {
      "parameters": {
        "jsCode": "// SQL ERROR HANDLER - Self-Healing Pattern\n// Research: Self-correcting SQL generation (2025)\n\nconst executorResult = $json;\nconst validatorData = $node['SQL Validator (Shield #1)'].json;\nconst originalQuery = $node['Init & ACL'].json.query;\nconst schemaContext = $node['Schema Context Builder'].json.schema_context;\nconst tenantId = $node['Init & ACL'].json.user_context.tenant_id;\n\n// Get static data for retry tracking\nconst staticData = $getWorkflowStaticData('global');\nconst traceId = $node['Init & ACL'].json.trace_id || 'sql-' + Date.now();\n\nif (!staticData.sqlRetries) staticData.sqlRetries = {};\nif (!staticData.sqlRetries[traceId]) {\n  staticData.sqlRetries[traceId] = { count: 0, errors: [] };\n}\n\nconst retryState = staticData.sqlRetries[traceId];\nconst MAX_RETRIES = 3;\n\n// Check if execution was successful\nconst hasError = executorResult.error || \n                 executorResult.errorMessage || \n                 (Array.isArray(executorResult) && executorResult.length === 0 && validatorData.sql?.includes('WHERE'));\n\nif (!hasError) {\n  // Success - cleanup and pass through\n  delete staticData.sqlRetries[traceId];\n  return {\n    success: true,\n    needs_repair: false,\n    result: executorResult,\n    sql_used: validatorData.sql,\n    retry_count: retryState.count\n  };\n}\n\n// Error detected - check retry limit\nretryState.count++;\nconst errorMessage = executorResult.error || executorResult.errorMessage || 'Empty result set (possible invalid query)';\nretryState.errors.push(errorMessage);\n\nif (retryState.count >= MAX_RETRIES) {\n  // Max retries reached - return failure\n  delete staticData.sqlRetries[traceId];\n  return {\n    success: false,\n    needs_repair: false,\n    error: 'MAX_RETRIES_EXCEEDED',\n    error_history: retryState.errors,\n    retry_count: retryState.count,\n    fallback_message: `Impossible de g\u00e9n\u00e9rer une requ\u00eate SQL valide apr\u00e8s ${MAX_RETRIES} tentatives.`\n  };\n}\n\n// Need repair - prepare context for SQL Repair LLM\nreturn {\n  success: false,\n  needs_repair: true,\n  retry_count: retryState.count,\n  repair_context: {\n    original_question: originalQuery,\n    failed_sql: validatorData.sql,\n    error_message: errorMessage,\n    schema_context: schemaContext,\n    tenant_id: tenantId,\n    previous_errors: retryState.errors\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1392,
        416
      ],
      "id": "37d15e46-31a0-40d5-9baa-77b573a8ee6e",
      "name": "SQL Error Handler (Self-Healing)"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.OPENROUTER_BASE_URL || 'https://openrouter.ai/api/v1/chat/completions' }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openRouterApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {
          "timeout": 20000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1872,
        480
      ],
      "id": "62e9e6c2-a7b6-4f8f-baf1-8eef71eb898c",
      "name": "SQL Repair LLM",
      "credentials": {
        "httpHeaderAuth": {
          "id": "nTJdf91Z5vhsI7cm",
          "name": "Unstructured API"
        },
        "openRouterApi": {
          "id": "aTHBqnntMBApo0Dy",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "conditions": [
                {
                  "leftValue": "={{ $json.needs_repair }}",
                  "rightValue": true,
                  "operator": {
                    "type": "boolean",
                    "operation": "equals"
                  }
                }
              ]
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1568,
        240
      ],
      "id": "9ea1857a-7959-4480-8a05-962791dd7a5f",
      "name": "Needs SQL Repair?"
    },
    {
      "parameters": {
        "jsCode": "// Parse SQL Repair response and prepare for retry\nconst repairResponse = $json;\nlet repairedSql = '';\n\ntry {\n  const content = repairResponse.choices?.[0]?.message?.content || repairResponse.body?.choices?.[0]?.message?.content;\n  const parsed = JSON.parse(content);\n  repairedSql = parsed.sql;\n} catch (e) {\n  // If parsing fails, return error\n  return {\n    success: false,\n    error: 'SQL_REPAIR_PARSE_ERROR',\n    raw_response: repairResponse\n  };\n}\n\n// Prepare for SQL Validator re-run\nreturn {\n  sql: repairedSql,\n  is_repaired: true,\n  repair_iteration: $node['SQL Error Handler (Self-Healing)'].json.retry_count\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2096,
        480
      ],
      "id": "92c3d6ed-285f-4816-b5c6-5173b374cf65",
      "name": "Repair Parser"
    },
    {
      "parameters": {
        "content": "# \ud83d\udd27 VARIABLES D'ENVIRONNEMENT REQUISES (SOTA 2026)\n\n## LLM APIs\n- `DEEPSEEK_API_KEY` - API key DeepSeek (api.deepseek.com)\n- `ANTHROPIC_API_KEY` - API key Anthropic (pour planning)\n- `GOOGLE_API_KEY` - API key Google (Gemini Flash)\n\n## LLM URLs (optionnel - d\u00e9fauts inclus)\n- `SQL_GENERATION_API_URL` - URL API pour SQL\n- `INTENT_ANALYSIS_API_URL` - URL API pour intent\n- `PLANNING_API_URL` - URL API pour planning\n- `GENERATION_API_URL` - URL API pour g\u00e9n\u00e9ration\n\n## LLM Models (optionnel)\n- `SQL_GENERATION_MODEL` = deepseek-chat\n- `INTENT_ANALYSIS_MODEL` = deepseek-chat\n- `PLANNING_MODEL` = claude-sonnet-4-5-20250929\n- `GENERATION_MODEL` = deepseek-chat\n\n## Embedding (RECOMMAND\u00c9: self-hosted)\n- `EMBEDDING_API_URL` - URL embedding (d\u00e9faut: OpenAI)\n- `EMBEDDING_MODEL` - text-embedding-3-small \u2192 Qwen3-Embedding-8B\n\n## Reranking (RECOMMAND\u00c9: self-hosted)\n- `RERANKER_API_URL` - URL reranker (d\u00e9faut: Cohere)\n- `RERANKER_MODEL` - rerank-v3 \u2192 Qwen3-Reranker-8B\n\n## Impact estim\u00e9 (selon research):\n- -89% co\u00fbt ingestion\n- -95% co\u00fbt requ\u00eates\n- +3% accuracy SQL (BIRD-SQL)\n- +15 pts MTEB (embedding)\n",
        "height": 600,
        "width": 400
      },
      "id": "caefcce7-a945-4749-bc3d-fbb4efc23bdc",
      "name": "\ud83d\udccb Configuration SOTA 2026",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -496,
        208
      ]
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        16,
        208
      ],
      "id": "1aa72ae4-5080-4b72-9a03-898056161710",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "public": true,
        "availableInChat": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.4,
      "position": [
        0,
        0
      ],
      "id": "c97d44ab-afc1-4640-a369-3ba05aedafc3",
      "name": "When chat message received",
      "webhookId": "326acdfb-3e93-4cc0-8548-1f6e17a4e335"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "3e0f8010-39e0-4bca-9d19-35e5094391a9",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        0,
        432
      ],
      "id": "6598d255-2b2a-4afe-9fc8-cd97d1f066e7",
      "name": "Webhook",
      "webhookId": "3e0f8010-39e0-4bca-9d19-35e5094391a9"
    },
    {
      "parameters": {
        "jsCode": "// Prepare SQL Request - Safe JSON Building\nconst initData = $node['Schema Context Builder'].json;\n\nconst requestBody = {\n  model: $vars.LLM_SQL_MODEL || 'deepseek/deepseek-chat',\n  messages: [\n    {\n      role: \"system\",\n      content: `You are an expert SQL generator with explicit Chain-of-Thought reasoning.\n\n=== 4-STEP METHOD ===\n\nSTEP 1 - UNDERSTAND THE QUESTION:\n- Identify ENTITIES mentioned (probable tables)\n- Identify METRICS requested (SUM, COUNT, AVG, etc.)\n- Identify FILTERS and CONDITIONS\n- Identify the TIME PERIOD if present\n\nSTEP 2 - MAP TO SCHEMA:\n- Find relevant tables in the provided schema\n- Identify EXACT column names (respect case!)\n- Verify data types\n- If you don't know the exact format of a value (e.g., quarter), use LIKE with wildcard.\n- CRITICAL: Use the EXACT sample values provided in the schema for company names, categories, etc.\n  Example: company_name = 'TechVision Inc' (NOT 'TechVision' or 'techvision')\n- When the user mentions a company by partial name, match it to the closest sample value.\nExample: quarter LIKE 'Q3%' instead of quarter = 'Q3'\n- Identify necessary JOINs\n\nSTEP 3 - BUILD THE QUERY:\n- SELECT: columns to return\n- FROM: main table\n- JOIN: if multi-table\n- WHERE: filters + tenant_id = '${initData.user_context.tenant_id}'\n- GROUP BY: if aggregation\n- ORDER BY: if sorting requested\n- LIMIT: max 1000\n\nSTEP 4 - VERIFY:\n- Is the query syntactically valid?\n- Does it answer the original question?\n- Do the column names exist in the schema?\n\n=== SECURITY RULES ===\n1. ALWAYS start with SELECT\n2. ALWAYS include tenant_id in WHERE\n3. ALWAYS LIMIT (max 1000)\n4. NEVER use DELETE, UPDATE, INSERT, DROP, TRUNCATE, ALTER, CREATE\n5. NEVER use SQL comments (--)\n\n=== STRICT JSON FORMAT ===\n{\n  \"reasoning\": {\n    \"entities_found\": [\"...\"],\n    \"metrics_needed\": [\"...\"],\n    \"filters_identified\": [\"...\"],\n    \"tables_used\": [\"...\"],\n    \"joins_needed\": [\"...\"],\n    \"potential_issues\": [\"...\"]\n  },\n  \"sql\": \"SELECT ... FROM ... WHERE tenant_id = '<TENANT_ID>' LIMIT 1000\",\n  \"explanation\": \"This query does X because Y\",\n  \"confidence\": 0.0-1.0\n}`\n    },\n    {\n      role: \"user\",\n      content: `=== USER QUESTION ===\n${initData.query}\n\n=== AVAILABLE SCHEMA ===\n${initData.schema_context}\n\n=== CONTEXT ===\nTenant ID: ${initData.user_context.tenant_id}\nGroups: ${JSON.stringify(initData.user_context.groups)}\n\nGenerate the SQL query with complete Chain-of-Thought reasoning.`\n    }\n  ],\n  temperature: 0.1,\n  max_tokens: 1000,\n  response_format: { type: \"json_object\" }\n};\n\nreturn {\n  json: {\n    requestBody: requestBody\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        688,
        464
      ],
      "id": "817873e1-b27e-41e8-9767-356782ae9429",
      "name": "Prepare SQL Request"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Interpretation Request - Safe JSON Building\nconst aggregatorData = $node['Result Aggregator'].json;\n\nconst requestBody = {\n  model: $vars.LLM_FAST_MODEL || 'google/gemini-2.5-flash-preview-05-20',\n  messages: [\n    {\n      role: \"system\",\n      content: \"You are an expert financial analyst. Interpret the SQL results and answer the original question clearly and concisely. Always respond in the same language as the question. If the data is empty, explain why.\"\n    },\n    {\n      role: \"user\",\n      content: `Original question: ${aggregatorData.query}\n\nExecuted SQL query: ${aggregatorData.validated_sql}\n\nResults (${aggregatorData.result_count} rows):\n${aggregatorData.result_preview}`\n    }\n  ],\n  temperature: 0.3,\n  max_tokens: 800\n};\n\nreturn {\n  json: {\n    ...aggregatorData,\n    requestBody: requestBody\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1632,
        0
      ],
      "id": "330eeb68-886e-428f-b453-297cb2094b5d",
      "name": "Prepare Interpretation Request"
    },
    {
      "parameters": {
        "jsCode": "// Prepare SQL Repair Request - Safe JSON Building\nconst errorHandlerData = $json;\nconst repairContext = errorHandlerData.repair_context;\n\nconst requestBody = {\n  model: $vars.LLM_SQL_MODEL || 'deepseek/deepseek-chat',\n  messages: [\n    {\n      role: \"system\",\n      content: `You are an expert SQL debugger. Your mission is to FIX a SQL query that has failed.\n\n=== RULES ===\n1. Fix ONLY the error - do NOT change the business logic\n2. Verify EXACT column names in the schema\n3. Add CAST if type mismatch (e.g., '100'::numeric)\n4. Verify quotes (single for strings, double for identifiers)\n5. ALWAYS keep tenant_id in WHERE\n\n=== JSON FORMAT ===\n{\n  \"analysis\": \"What caused the error...\",\n  \"fix_applied\": \"The change made...\",\n  \"sql\": \"SELECT ... (corrected query)\",\n  \"confidence\": 0.0-1.0\n}`\n    },\n    {\n      role: \"user\",\n      content: `=== ORIGINAL QUERY THAT FAILED ===\n${repairContext.failed_sql}\n\n=== POSTGRES ERROR ===\n${repairContext.error_message}\n\n=== SCHEMA ===\n${repairContext.schema_context}\n\n=== USER QUESTION ===\n${repairContext.original_question}\n\n=== ERROR HISTORY ===\n${JSON.stringify(repairContext.previous_errors, null, 2)}\n\nFix the SQL query. Return ONLY the JSON with the corrected query.`\n    }\n  ],\n  temperature: 0.1,\n  max_tokens: 800,\n  response_format: { type: \"json_object\" }\n};\n\nreturn {\n  json: {\n    ...errorHandlerData,\n    requestBody: requestBody\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1696,
        480
      ],
      "id": "585ba1b1-1f92-4703-b30e-c245342df589",
      "name": "Prepare SQL Repair Request"
    }
  ],
  "pinData": {},
  "connections": {
    "Init & ACL": {
      "main": [
        [
          {
            "node": "Schema Introspection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schema Introspection": {
      "main": [
        [
          {
            "node": "Schema Context Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schema Context Builder": {
      "main": [
        [
          {
            "node": "Prepare SQL Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Text-to-SQL Generator (CoT Enhanced)": {
      "main": [
        [
          {
            "node": "SQL Validator (Shield #1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Validator (Shield #1)": {
      "main": [
        [
          {
            "node": "SQL Executor (Postgres)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Executor (Postgres)": {
      "main": [
        [
          {
            "node": "Result Aggregator",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "SQL Error Handler (Self-Healing)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Result Aggregator": {
      "main": [
        [
          {
            "node": "Prepare Interpretation Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpretation Layer (LLM Analyst)": {
      "main": [
        [
          {
            "node": "Response Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response Formatter": {
      "main": [
        [
          {
            "node": "OTEL Export (Shield #9)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Error Response Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Error Handler (Self-Healing)": {
      "main": [
        [
          {
            "node": "Needs SQL Repair?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs SQL Repair?": {
      "main": [
        [
          {
            "node": "Prepare SQL Repair Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Repair LLM": {
      "main": [
        [
          {
            "node": "Repair Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repair Parser": {
      "main": [
        [
          {
            "node": "SQL Validator (Shield #1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Init & ACL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "Init & ACL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Init & ACL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare SQL Request": {
      "main": [
        [
          {
            "node": "Text-to-SQL Generator (CoT Enhanced)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Interpretation Request": {
      "main": [
        [
          {
            "node": "Interpretation Layer (LLM Analyst)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare SQL Repair Request": {
      "main": [
        [
          {
            "node": "SQL Repair LLM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": true,
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "3bea31e7-c3d0-42cf-a6d0-c63f38861b3e",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "810d143e45edb75891ee3244decd00dc613435a73f5b3ad2900fe9bc764e9d73"
  },
  "id": "xrzL7TRX9F0UrWks0tdCI",
  "tags": []
}